grammar ALTL;

options {
  language = Java;
}

import FormulaRules, FormulaTokens;

@header {
  package fr.inria.plasmalab.altl.parser;

  import java.util.HashMap;
  import java.util.Map;
  import java.util.List;
  import java.util.ArrayList;

  import fr.inria.plasmalab.altl.ast.Adaptive;
  import fr.inria.plasmalab.altl.ast.IdentExpr;
  import fr.inria.plasmalab.bltl.ast.*;
  import fr.inria.plasmalab.bltl.ast.nodes.*;
  import fr.inria.plasmalab.bltl.ast.leaves.*;
  import fr.inria.plasmalab.bltl.ast.leaves.FloatExpr;
  import fr.inria.plasmalab.bltl.ast.operators.*;
  import fr.inria.plasmalab.workflow.concrete.GenericIdentifier;
  import fr.inria.plasmalab.workflow.concrete.Variable;
  import fr.inria.plasmalab.workflow.concrete.VariableType;
  import fr.inria.plasmalab.workflow.concrete.Range;
  import fr.inria.plasmalab.workflow.data.simulation.InterfaceIdentifier;
  import fr.inria.plasmalab.workflow.concrete.GenericIdentifier;
  // Required and generated by FormulaRules.g
  import fr.inria.plasmalab.bltl.parser.BoundExpr;
  import fr.inria.plasmalab.workflow.exceptions.PlasmaDataException;
  import fr.inria.plasmalab.workflow.exceptions.PlasmaSyntaxException;
}

@lexer::header {
  package fr.inria.plasmalab.altl.parser;
}

@rulecatch {
    catch (RecognitionException re) {
        //displayRecognitionError(re);
        reportError(re);
        //recover(input,re);
        //throw re;
    }
}
@members {
    public static final String[] tokenNamesTranslated = new String[] {    
    "<invalid>", "<EOR>", "<DOWN>", "<UP>", "'+'", "upper and lower case alpha characters", "'&'", "'BLTL'", 
    "':'", "':='", "','", "COMMENTS", "'declare'", "DIGITS", "'/'", "'.'", "' \" '", "'end'", "'='", "'false'", 
    "'F'", "floating point number", "'>='", "'G'", "'>'", "an alpha-numerical identifier starting with a letter or '_'",
     "dot separated identifiers", "'=>'", "'['", 
    "'<='", "'('", "'<'", "'-'", "'*'", "'!='", "'X'", "'!'", "'==>'", "'optimize'", "'|'", "' ' '",
    "']'", "')'", "';'", "'#'", "'true'", "'U'", "'W'", "WHITESPACE"
  };

  private List<PlasmaDataException> errors = new ArrayList<PlasmaDataException>();
  public List<PlasmaDataException> getErrors() {
        return errors;
  }
  
       @Override
     protected Object recoverFromMismatchedToken (IntStream input,int 
ttype,BitSet follow) throws RecognitionException{
         // Desactivate recover from Mismatched input
         throw new MismatchedTokenException (ttype, input);
     }

     @Override
     public void reportError (RecognitionException e){
         String hdr = getErrorHeader(e);
         String msg = getErrorMessage(e, this.tokenNames);
         PlasmaSyntaxException pse = new PlasmaSyntaxException(hdr+" - "+msg, e);
         errors.add(pse);
         // throw pse;
     }
     
     //Override error message
  @Override
  public String getErrorMessage(RecognitionException e, String[] tokenNames) {
    String msg = e.getMessage();
    if ( e instanceof UnwantedTokenException ) {
      UnwantedTokenException ute = (UnwantedTokenException)e;
      String tokenName;
      if ( ute.expecting== Token.EOF ) {
        tokenName = "EOF";
      }
      else {
        tokenName = tokenNamesTranslated[ute.expecting];
      }
      msg = "extraneous input "+getTokenErrorDisplay(ute.getUnexpectedToken())+
        " expecting "+tokenName;
    }
    else if ( e instanceof MissingTokenException ) {
      MissingTokenException mte = (MissingTokenException)e;
      String tokenName;
      if ( mte.expecting== Token.EOF ) {
        tokenName = "EOF";
      }
      else {
        tokenName = tokenNamesTranslated[mte.expecting];
      }
      msg = "missing "+tokenName+" at "+getTokenErrorDisplay(e.token);
    }
    else if ( e instanceof MismatchedTokenException ) {
      MismatchedTokenException mte = (MismatchedTokenException)e;
      String tokenName;
      if ( mte.expecting== Token.EOF ) {
        tokenName = "EOF";
      }
      else {
        tokenName = tokenNamesTranslated[mte.expecting];
      }
      msg = "mismatched input "+getTokenErrorDisplay(e.token)+
        " expecting "+tokenName;
    }
    else if ( e instanceof MismatchedTreeNodeException ) {
      MismatchedTreeNodeException mtne = (MismatchedTreeNodeException)e;
      String tokenName;
      if ( mtne.expecting==Token.EOF ) {
        tokenName = "EOF";
      }
      else {
        tokenName = tokenNamesTranslated[mtne.expecting];
      }
      msg = "mismatched tree node: "+mtne.node+
        " expecting "+tokenName;
    }
    else if ( e instanceof NoViableAltException ) {
      //NoViableAltException nvae = (NoViableAltException)e;
      // for development, can add "decision=<<"+nvae.grammarDecisionDescription+">>"
      // and "(decision="+nvae.decisionNumber+") and
      // "state "+nvae.stateNumber
      msg = "no viable alternative at input "+getTokenErrorDisplay(e.token);
    }
    else if ( e instanceof EarlyExitException ) {
      //EarlyExitException eee = (EarlyExitException)e;
      // for development, can add "(decision="+eee.decisionNumber+")"
      msg = "required (...)+ loop did not match anything at input "+
        getTokenErrorDisplay(e.token);
    }
    else if ( e instanceof MismatchedSetException ) {
      MismatchedSetException mse = (MismatchedSetException)e;
      msg = "mismatched input "+getTokenErrorDisplay(e.token)+
        " expecting set "+mse.expecting;
    }
    else if ( e instanceof MismatchedNotSetException ) {
      MismatchedNotSetException mse = (MismatchedNotSetException)e;
      msg = "mismatched input "+getTokenErrorDisplay(e.token)+
        " expecting set "+mse.expecting;
    }
    else if ( e instanceof FailedPredicateException ) {
      FailedPredicateException fpe = (FailedPredicateException)e;
      msg = "rule "+fpe.ruleName+" failed predicate: {"+
        fpe.predicateText+"}?";
    }
    return msg;
  }
}


// Override of FormulaRules.factor
// To introduce
factor returns [Expr val]      @init{ UnOp neg = null; }
: (MIN                              { neg = UnOp.Neg; }
      )? ( LP expr RP               { $val = $expr.val;}
         | ( id1=IDENT                  { $val = new IdentExpr(/*gFormulaRules.modelIdMap.get*/($id1.text)); }
           | DQ id2=IDENT DQ            { $val = new IdentExpr(/*gFormulaRules.modelIdMap.get*/("\"" + $id2.text + "\"")); }
           )
                  (QUOTE            { ((IdentExpr) $val).prime = true; }
                        )?
         | number                   { $val = new FloatExpr($number.val);}
         | TRUE                     { $val = new BoolExpr(true);  }
         | FALSE                    { $val = new BoolExpr(false); }
  )                                 { $val = neg == null ? $val : new Expr1(neg, $val); }
;



formula returns [Expr val]          @init{ gFormulaRules.optimizationVariables = new ArrayList<Variable>(); 
                                     gFormulaRules.requirementVarMap = new HashMap<String,Variable>();}
:   (declareVars? optimizeVars? END)? 
                      aexpr               { $val = $aexpr.val; }
;


// Adaptive is right assoc :
// a; [t] ==> c; [t'] ==> c' [t''] ==> c''
//        is interpreted as
// a; [t] ==> (c; [t'] ==> (c' [t''] ==> c''))

aexpr returns [Expr val]                               @init{ Stack<Expr> st = new Stack<Expr>();
                                                              Stack<BoundExpr> stb = new Stack<BoundExpr>();
                                                              Stack<Adaptive.Modality> stm = new Stack<Adaptive.Modality>(); }
: a=expr                                                    { st.push($a.val); }

  (   SEMI '[' t1=trigger ',' t2=trigger  ']'               { stb.push(null); }
      ( b1=bound                                            { stb.pop();
                                                              stb.push($b1.val); }
      )?
      OCCURS c1=expr                                        { st.push($t1.val);
                                                              st.push($t2.val);
                                                              st.push($c1.val);
                                                              stm.push(Adaptive.Modality.May); }
  | OCCURS '[' t3=trigger ',' t4=trigger  ']'               { stb.push(null); }
    (b2=bound                                               { stb.pop();
                                                              stb.push($b2.val); }
    )?
    SEMI c2=expr                                            { st.push($t3.val);
                                                              st.push($t4.val);
                                                              st.push($c2.val);
                                                              stm.push(Adaptive.Modality.Must); }
  )*                                                        {  // invariant: \exists k >= 0, st.size == 2 * k + 1
                                                               val = st.pop();
                                                               while (!st.isEmpty()) {
                                                                  Expr post_trigger = st.pop();
	                                                                Expr pre_trigger = st.pop();
	                                                                Expr assumption = st.pop();
	                                                                BoundExpr bound = stb.pop(); // bound may be null
	                                                                Adaptive.Modality mod = stm.pop();
	                                                                val = new Adaptive(assumption,pre_trigger,post_trigger,bound,val,mod);
                                                               }
                                                            }
;

trigger returns [Expr val]
: l=disjunction2                           { val = l; }
                (IMP r=disjunction2        { val = new Expr2(val, BinOp.Imp, r); }
                                   )*
;

disjunction2 returns [Expr val]
: l=conjunction2                           { val = l; }
                (OR r=conjunction2         { val = new Expr2(val, BinOp.Or, r); }
                                  )*
;

conjunction2 returns [Expr val]:
  l=equality2                              { val = l; }
             (AND r=equality2              { val = new Expr2(val, BinOp.And, r); }
                             )*
;

equality2 returns [Expr val]          @init{ UnOp neg = null; }
: (NOT                                     { neg = UnOp.Not ; }
      )? l=relExp2                         { val = $l.val; }
                  (eop r=relExp2           { val = new Expr2($l.val, $eop.val, $r.val); }
                                )?         { val = neg == null ? val : new Expr1(neg, val); }
;


relExp2 returns [Expr val]
: l=numExp2                                { val = l; }
           (rop r=numExp2                  { val = new Expr2(l, $rop.val, r); }
                         )?
;


numExp2 returns [Expr val]:
  l=term2                                  { val = l; }
         (nop r=term2                      { val = new Expr2(val, $nop.val, r); }
                     )*
;


term2 returns [Expr val]
: l=factor2                                { $val = $l.val; }
           (top r=factor2                  { $val = new Expr2($val, $top.val, $r.val); }
                         )*
;

top2 returns [BinOp val]
: MUL                 { val = BinOp.Mul; }
| DIV                 { val = BinOp.Div; }
;


factor2 returns [Expr val]     @init{ UnOp neg = null; }
: (MIN                              { neg = UnOp.Neg; }
      )? ( priority2                { $val = $priority2.val;}
         | ( id1=IDENT                  { $val = new IdentExpr(/*gFormulaRules.modelIdMap.get*/($id1.text)); }
           | DQ id2=IDENT DQ            { $val = new IdentExpr(/*gFormulaRules.modelIdMap.get*/("\"" + $id2.text + "\"")); }
           )
                  (QUOTE            { ((IdentExpr) $val).prime = true; }
                        )?
         | number                   { $val = new FloatExpr($number.val);}
         | TRUE                     { $val = new BoolExpr(true);   }
         | FALSE                    { $val = new BoolExpr(false);  }
  )                                 { $val = neg == null ? $val : new Expr1(neg, $val);  }
;

priority2 returns [Expr val]
: LP trigger RP                     { $val = $trigger.val; }
;
// The definition is recursively done over trigger and not expr:
// It excludes all behavioral property in the trigger.


QUOTE: '\'';
OCCURS: '==>';

// DO NOT REMOVE:
// Without it, Antlr will not generate the expected Lexer : 1 token must be at less defined.
// DUMMY: 'dummy';
