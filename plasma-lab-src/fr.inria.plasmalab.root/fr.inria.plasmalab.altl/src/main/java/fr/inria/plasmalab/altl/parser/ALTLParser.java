/**
 * This file is part of fr.inria.plasmalab.altl.
 *
 * fr.inria.plasmalab.altl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * fr.inria.plasmalab.altl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with fr.inria.plasmalab.altl.  If not, see <http://www.gnu.org/licenses/>.
 */
// $ANTLR 3.4 ALTL.g 2017-02-23 16:23:36

  package fr.inria.plasmalab.altl.parser;

  import java.util.HashMap;
  import java.util.Map;
  import java.util.List;
  import java.util.ArrayList;

  import fr.inria.plasmalab.altl.ast.Adaptive;
  import fr.inria.plasmalab.altl.ast.IdentExpr;
  import fr.inria.plasmalab.bltl.ast.*;
  import fr.inria.plasmalab.bltl.ast.nodes.*;
  import fr.inria.plasmalab.bltl.ast.leaves.*;
  import fr.inria.plasmalab.bltl.ast.leaves.FloatExpr;
  import fr.inria.plasmalab.bltl.ast.operators.*;
  import fr.inria.plasmalab.workflow.concrete.GenericIdentifier;
  import fr.inria.plasmalab.workflow.concrete.Variable;
  import fr.inria.plasmalab.workflow.concrete.VariableType;
  import fr.inria.plasmalab.workflow.concrete.Range;
  import fr.inria.plasmalab.workflow.data.simulation.InterfaceIdentifier;
  import fr.inria.plasmalab.workflow.concrete.GenericIdentifier;
  // Required and generated by FormulaRules.g
  import fr.inria.plasmalab.bltl.parser.BoundExpr;
  import fr.inria.plasmalab.workflow.exceptions.PlasmaDataException;
  import fr.inria.plasmalab.workflow.exceptions.PlasmaSyntaxException;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

@SuppressWarnings({"all", "warnings", "unchecked"})
public class ALTLParser extends Parser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "ALPHA", "AND", "BLTL", "COL", "COLEQ", "COMMA", "COMMENTS", "DEADLOCK", "DECLARE", "DIGITS", "DIV", "DOT", "DQ", "END", "EQ", "FALSE", "FATALLY", "FLOATING", "GE", "GLOBALLY", "GT", "ID", "IDENT", "IMP", "LB", "LC", "LE", "LP", "LT", "MIN", "MUL", "NEQ", "NEXT", "NOT", "OCCURS", "OPTIMIZE", "OR", "OVERRIDE", "QUOTE", "RB", "RC", "REWARD", "RP", "SEMI", "SH", "TRUE", "UNTIL", "WEAK", "WHITESPACE"
    };

    public static final int EOF=-1;
    public static final int ADD=4;
    public static final int ALPHA=5;
    public static final int AND=6;
    public static final int BLTL=7;
    public static final int COL=8;
    public static final int COLEQ=9;
    public static final int COMMA=10;
    public static final int COMMENTS=11;
    public static final int DEADLOCK=12;
    public static final int DECLARE=13;
    public static final int DIGITS=14;
    public static final int DIV=15;
    public static final int DOT=16;
    public static final int DQ=17;
    public static final int END=18;
    public static final int EQ=19;
    public static final int FALSE=20;
    public static final int FATALLY=21;
    public static final int FLOATING=22;
    public static final int GE=23;
    public static final int GLOBALLY=24;
    public static final int GT=25;
    public static final int ID=26;
    public static final int IDENT=27;
    public static final int IMP=28;
    public static final int LB=29;
    public static final int LC=30;
    public static final int LE=31;
    public static final int LP=32;
    public static final int LT=33;
    public static final int MIN=34;
    public static final int MUL=35;
    public static final int NEQ=36;
    public static final int NEXT=37;
    public static final int NOT=38;
    public static final int OCCURS=39;
    public static final int OPTIMIZE=40;
    public static final int OR=41;
    public static final int OVERRIDE=42;
    public static final int QUOTE=43;
    public static final int RB=44;
    public static final int RC=45;
    public static final int REWARD=46;
    public static final int RP=47;
    public static final int SEMI=48;
    public static final int SH=49;
    public static final int TRUE=50;
    public static final int UNTIL=51;
    public static final int WEAK=52;
    public static final int WHITESPACE=53;

    // delegates
    public ALTL_FormulaRules gFormulaRules;
    public Parser[] getDelegates() {
        return new Parser[] {gFormulaRules};
    }

    // delegators


    public ALTLParser(TokenStream input) {
        this(input, new RecognizerSharedState());
    }
    public ALTLParser(TokenStream input, RecognizerSharedState state) {
        super(input, state);
        gFormulaRules = new ALTL_FormulaRules(input, state, this);
    }

    public String[] getTokenNames() { return ALTLParser.tokenNames; }
    public String getGrammarFileName() { return "ALTL.g"; }


        public static final String[] tokenNamesTranslated = new String[] {    
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "'+'", "upper and lower case alpha characters", "'&'", "'BLTL'", 
        "':'", "':='", "','", "COMMENTS", "'declare'", "DIGITS", "'/'", "'.'", "' \" '", "'end'", "'='", "'false'", 
        "'F'", "floating point number", "'>='", "'G'", "'>'", "an alpha-numerical identifier starting with a letter or '_'",
         "dot separated identifiers", "'=>'", "'['", 
        "'<='", "'('", "'<'", "'-'", "'*'", "'!='", "'X'", "'!'", "'==>'", "'optimize'", "'|'", "' ' '",
        "']'", "')'", "';'", "'#'", "'true'", "'U'", "'W'", "WHITESPACE"
      };

      private List<PlasmaDataException> errors = new ArrayList<PlasmaDataException>();
      public List<PlasmaDataException> getErrors() {
            return errors;
      }
      
           @Override
         protected Object recoverFromMismatchedToken (IntStream input,int 
    ttype,BitSet follow) throws RecognitionException{
             // Desactivate recover from Mismatched input
             throw new MismatchedTokenException (ttype, input);
         }

         @Override
         public void reportError (RecognitionException e){
             String hdr = getErrorHeader(e);
             String msg = getErrorMessage(e, this.tokenNames);
             PlasmaSyntaxException pse = new PlasmaSyntaxException(hdr+" - "+msg, e);
             errors.add(pse);
             // throw pse;
         }
         
         //Override error message
      @Override
      public String getErrorMessage(RecognitionException e, String[] tokenNames) {
        String msg = e.getMessage();
        if ( e instanceof UnwantedTokenException ) {
          UnwantedTokenException ute = (UnwantedTokenException)e;
          String tokenName;
          if ( ute.expecting== Token.EOF ) {
            tokenName = "EOF";
          }
          else {
            tokenName = tokenNamesTranslated[ute.expecting];
          }
          msg = "extraneous input "+getTokenErrorDisplay(ute.getUnexpectedToken())+
            " expecting "+tokenName;
        }
        else if ( e instanceof MissingTokenException ) {
          MissingTokenException mte = (MissingTokenException)e;
          String tokenName;
          if ( mte.expecting== Token.EOF ) {
            tokenName = "EOF";
          }
          else {
            tokenName = tokenNamesTranslated[mte.expecting];
          }
          msg = "missing "+tokenName+" at "+getTokenErrorDisplay(e.token);
        }
        else if ( e instanceof MismatchedTokenException ) {
          MismatchedTokenException mte = (MismatchedTokenException)e;
          String tokenName;
          if ( mte.expecting== Token.EOF ) {
            tokenName = "EOF";
          }
          else {
            tokenName = tokenNamesTranslated[mte.expecting];
          }
          msg = "mismatched input "+getTokenErrorDisplay(e.token)+
            " expecting "+tokenName;
        }
        else if ( e instanceof MismatchedTreeNodeException ) {
          MismatchedTreeNodeException mtne = (MismatchedTreeNodeException)e;
          String tokenName;
          if ( mtne.expecting==Token.EOF ) {
            tokenName = "EOF";
          }
          else {
            tokenName = tokenNamesTranslated[mtne.expecting];
          }
          msg = "mismatched tree node: "+mtne.node+
            " expecting "+tokenName;
        }
        else if ( e instanceof NoViableAltException ) {
          //NoViableAltException nvae = (NoViableAltException)e;
          // for development, can add "decision=<<"+nvae.grammarDecisionDescription+">>"
          // and "(decision="+nvae.decisionNumber+") and
          // "state "+nvae.stateNumber
          msg = "no viable alternative at input "+getTokenErrorDisplay(e.token);
        }
        else if ( e instanceof EarlyExitException ) {
          //EarlyExitException eee = (EarlyExitException)e;
          // for development, can add "(decision="+eee.decisionNumber+")"
          msg = "required (...)+ loop did not match anything at input "+
            getTokenErrorDisplay(e.token);
        }
        else if ( e instanceof MismatchedSetException ) {
          MismatchedSetException mse = (MismatchedSetException)e;
          msg = "mismatched input "+getTokenErrorDisplay(e.token)+
            " expecting set "+mse.expecting;
        }
        else if ( e instanceof MismatchedNotSetException ) {
          MismatchedNotSetException mse = (MismatchedNotSetException)e;
          msg = "mismatched input "+getTokenErrorDisplay(e.token)+
            " expecting set "+mse.expecting;
        }
        else if ( e instanceof FailedPredicateException ) {
          FailedPredicateException fpe = (FailedPredicateException)e;
          msg = "rule "+fpe.ruleName+" failed predicate: {"+
            fpe.predicateText+"}?";
        }
        return msg;
      }



    // $ANTLR start "factor"
    // ALTL.g:165:1: factor returns [Expr val] : ( MIN )? ( LP expr RP | (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )? | number | TRUE | FALSE ) ;
    public final Expr factor() throws RecognitionException {
        Expr val = null;


        Token id1=null;
        Token id2=null;
        Expr expr1 =null;

        double number2 =0.0;


         UnOp neg = null; 
        try {
            // ALTL.g:166:3: ( ( MIN )? ( LP expr RP | (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )? | number | TRUE | FALSE ) )
            // ALTL.g:166:3: ( MIN )? ( LP expr RP | (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )? | number | TRUE | FALSE )
            {
            // ALTL.g:166:3: ( MIN )?
            int alt1=2;
            int LA1_0 = input.LA(1);

            if ( (LA1_0==MIN) ) {
                alt1=1;
            }
            switch (alt1) {
                case 1 :
                    // ALTL.g:166:4: MIN
                    {
                    match(input,MIN,FOLLOW_MIN_in_factor76); 

                     neg = UnOp.Neg; 

                    }
                    break;

            }


            // ALTL.g:167:10: ( LP expr RP | (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )? | number | TRUE | FALSE )
            int alt4=5;
            switch ( input.LA(1) ) {
            case LP:
                {
                alt4=1;
                }
                break;
            case DQ:
            case IDENT:
                {
                alt4=2;
                }
                break;
            case DIGITS:
            case FLOATING:
                {
                alt4=3;
                }
                break;
            case TRUE:
                {
                alt4=4;
                }
                break;
            case FALSE:
                {
                alt4=5;
                }
                break;
            default:
                NoViableAltException nvae =
                    new NoViableAltException("", 4, 0, input);

                throw nvae;

            }

            switch (alt4) {
                case 1 :
                    // ALTL.g:167:12: LP expr RP
                    {
                    match(input,LP,FOLLOW_LP_in_factor120); 

                    pushFollow(FOLLOW_expr_in_factor122);
                    expr1=expr();

                    state._fsp--;


                    match(input,RP,FOLLOW_RP_in_factor124); 

                     val = expr1;

                    }
                    break;
                case 2 :
                    // ALTL.g:168:12: (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )?
                    {
                    // ALTL.g:168:12: (id1= IDENT | DQ id2= IDENT DQ )
                    int alt2=2;
                    int LA2_0 = input.LA(1);

                    if ( (LA2_0==IDENT) ) {
                        alt2=1;
                    }
                    else if ( (LA2_0==DQ) ) {
                        alt2=2;
                    }
                    else {
                        NoViableAltException nvae =
                            new NoViableAltException("", 2, 0, input);

                        throw nvae;

                    }
                    switch (alt2) {
                        case 1 :
                            // ALTL.g:168:14: id1= IDENT
                            {
                            id1=(Token)match(input,IDENT,FOLLOW_IDENT_in_factor157); 

                             val = new IdentExpr(/*gFormulaRules.modelIdMap.get*/((id1!=null?id1.getText():null))); 

                            }
                            break;
                        case 2 :
                            // ALTL.g:169:14: DQ id2= IDENT DQ
                            {
                            match(input,DQ,FOLLOW_DQ_in_factor191); 

                            id2=(Token)match(input,IDENT,FOLLOW_IDENT_in_factor195); 

                            match(input,DQ,FOLLOW_DQ_in_factor197); 

                             val = new IdentExpr(/*gFormulaRules.modelIdMap.get*/("\"" + (id2!=null?id2.getText():null) + "\"")); 

                            }
                            break;

                    }


                    // ALTL.g:171:19: ( QUOTE )?
                    int alt3=2;
                    int LA3_0 = input.LA(1);

                    if ( (LA3_0==QUOTE) ) {
                        alt3=1;
                    }
                    switch (alt3) {
                        case 1 :
                            // ALTL.g:171:20: QUOTE
                            {
                            match(input,QUOTE,FOLLOW_QUOTE_in_factor244); 

                             ((IdentExpr) val).prime = true; 

                            }
                            break;

                    }


                    }
                    break;
                case 3 :
                    // ALTL.g:173:12: number
                    {
                    pushFollow(FOLLOW_number_in_factor297);
                    number2=number();

                    state._fsp--;


                     val = new FloatExpr(number2);

                    }
                    break;
                case 4 :
                    // ALTL.g:174:12: TRUE
                    {
                    match(input,TRUE,FOLLOW_TRUE_in_factor330); 

                     val = new BoolExpr(true);  

                    }
                    break;
                case 5 :
                    // ALTL.g:175:12: FALSE
                    {
                    match(input,FALSE,FOLLOW_FALSE_in_factor365); 

                     val = new BoolExpr(false); 

                    }
                    break;

            }


             val = neg == null ? val : new Expr1(neg, val); 

            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "factor"



    // $ANTLR start "formula"
    // ALTL.g:181:1: formula returns [Expr val] : ( ( declareVars )? ( optimizeVars )? END )? aexpr ;
    public final Expr formula() throws RecognitionException {
        Expr val = null;


        Expr aexpr3 =null;


         gFormulaRules.optimizationVariables = new ArrayList<Variable>(); 
                                             gFormulaRules.requirementVarMap = new HashMap<String,Variable>();
        try {
            // ALTL.g:183:5: ( ( ( declareVars )? ( optimizeVars )? END )? aexpr )
            // ALTL.g:183:5: ( ( declareVars )? ( optimizeVars )? END )? aexpr
            {
            // ALTL.g:183:5: ( ( declareVars )? ( optimizeVars )? END )?
            int alt7=2;
            int LA7_0 = input.LA(1);

            if ( (LA7_0==DECLARE||LA7_0==END||LA7_0==OPTIMIZE) ) {
                alt7=1;
            }
            switch (alt7) {
                case 1 :
                    // ALTL.g:183:6: ( declareVars )? ( optimizeVars )? END
                    {
                    // ALTL.g:183:6: ( declareVars )?
                    int alt5=2;
                    int LA5_0 = input.LA(1);

                    if ( (LA5_0==DECLARE) ) {
                        alt5=1;
                    }
                    switch (alt5) {
                        case 1 :
                            // ALTL.g:183:6: declareVars
                            {
                            pushFollow(FOLLOW_declareVars_in_formula455);
                            declareVars();

                            state._fsp--;


                            }
                            break;

                    }


                    // ALTL.g:183:19: ( optimizeVars )?
                    int alt6=2;
                    int LA6_0 = input.LA(1);

                    if ( (LA6_0==OPTIMIZE) ) {
                        alt6=1;
                    }
                    switch (alt6) {
                        case 1 :
                            // ALTL.g:183:19: optimizeVars
                            {
                            pushFollow(FOLLOW_optimizeVars_in_formula458);
                            optimizeVars();

                            state._fsp--;


                            }
                            break;

                    }


                    match(input,END,FOLLOW_END_in_formula461); 

                    }
                    break;

            }


            pushFollow(FOLLOW_aexpr_in_formula488);
            aexpr3=aexpr();

            state._fsp--;


             val = aexpr3; 

            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "formula"



    // $ANTLR start "aexpr"
    // ALTL.g:193:1: aexpr returns [Expr val] : a= expr ( SEMI '[' t1= trigger ',' t2= trigger ']' (b1= bound )? OCCURS c1= expr | OCCURS '[' t3= trigger ',' t4= trigger ']' (b2= bound )? SEMI c2= expr )* ;
    public final Expr aexpr() throws RecognitionException {
        Expr val = null;


        Expr a =null;

        Expr t1 =null;

        Expr t2 =null;

        BoundExpr b1 =null;

        Expr c1 =null;

        Expr t3 =null;

        Expr t4 =null;

        BoundExpr b2 =null;

        Expr c2 =null;


         Stack<Expr> st = new Stack<Expr>();
                                                                      Stack<BoundExpr> stb = new Stack<BoundExpr>();
                                                                      Stack<Adaptive.Modality> stm = new Stack<Adaptive.Modality>(); 
        try {
            // ALTL.g:196:3: (a= expr ( SEMI '[' t1= trigger ',' t2= trigger ']' (b1= bound )? OCCURS c1= expr | OCCURS '[' t3= trigger ',' t4= trigger ']' (b2= bound )? SEMI c2= expr )* )
            // ALTL.g:196:3: a= expr ( SEMI '[' t1= trigger ',' t2= trigger ']' (b1= bound )? OCCURS c1= expr | OCCURS '[' t3= trigger ',' t4= trigger ']' (b2= bound )? SEMI c2= expr )*
            {
            pushFollow(FOLLOW_expr_in_aexpr559);
            a=expr();

            state._fsp--;


             st.push(a); 

            // ALTL.g:198:3: ( SEMI '[' t1= trigger ',' t2= trigger ']' (b1= bound )? OCCURS c1= expr | OCCURS '[' t3= trigger ',' t4= trigger ']' (b2= bound )? SEMI c2= expr )*
            loop10:
            do {
                int alt10=3;
                int LA10_0 = input.LA(1);

                if ( (LA10_0==SEMI) ) {
                    alt10=1;
                }
                else if ( (LA10_0==OCCURS) ) {
                    alt10=2;
                }


                switch (alt10) {
            	case 1 :
            	    // ALTL.g:198:7: SEMI '[' t1= trigger ',' t2= trigger ']' (b1= bound )? OCCURS c1= expr
            	    {
            	    match(input,SEMI,FOLLOW_SEMI_in_aexpr621); 

            	    match(input,LB,FOLLOW_LB_in_aexpr623); 

            	    pushFollow(FOLLOW_trigger_in_aexpr627);
            	    t1=trigger();

            	    state._fsp--;


            	    match(input,COMMA,FOLLOW_COMMA_in_aexpr629); 

            	    pushFollow(FOLLOW_trigger_in_aexpr633);
            	    t2=trigger();

            	    state._fsp--;


            	    match(input,RB,FOLLOW_RB_in_aexpr636); 

            	     stb.push(null); 

            	    // ALTL.g:199:7: (b1= bound )?
            	    int alt8=2;
            	    int LA8_0 = input.LA(1);

            	    if ( (LA8_0==LE) ) {
            	        alt8=1;
            	    }
            	    switch (alt8) {
            	        case 1 :
            	            // ALTL.g:199:9: b1= bound
            	            {
            	            pushFollow(FOLLOW_bound_in_aexpr664);
            	            b1=bound();

            	            state._fsp--;


            	             stb.pop();
            	                                                                          stb.push(b1); 

            	            }
            	            break;

            	    }


            	    match(input,OCCURS,FOLLOW_OCCURS_in_aexpr726); 

            	    pushFollow(FOLLOW_expr_in_aexpr730);
            	    c1=expr();

            	    state._fsp--;


            	     st.push(t1);
            	                                                                  st.push(t2);
            	                                                                  st.push(c1);
            	                                                                  stm.push(Adaptive.Modality.May); 

            	    }
            	    break;
            	case 2 :
            	    // ALTL.g:206:5: OCCURS '[' t3= trigger ',' t4= trigger ']' (b2= bound )? SEMI c2= expr
            	    {
            	    match(input,OCCURS,FOLLOW_OCCURS_in_aexpr777); 

            	    match(input,LB,FOLLOW_LB_in_aexpr779); 

            	    pushFollow(FOLLOW_trigger_in_aexpr783);
            	    t3=trigger();

            	    state._fsp--;


            	    match(input,COMMA,FOLLOW_COMMA_in_aexpr785); 

            	    pushFollow(FOLLOW_trigger_in_aexpr789);
            	    t4=trigger();

            	    state._fsp--;


            	    match(input,RB,FOLLOW_RB_in_aexpr792); 

            	     stb.push(null); 

            	    // ALTL.g:207:5: (b2= bound )?
            	    int alt9=2;
            	    int LA9_0 = input.LA(1);

            	    if ( (LA9_0==LE) ) {
            	        alt9=1;
            	    }
            	    switch (alt9) {
            	        case 1 :
            	            // ALTL.g:207:6: b2= bound
            	            {
            	            pushFollow(FOLLOW_bound_in_aexpr817);
            	            b2=bound();

            	            state._fsp--;


            	             stb.pop();
            	                                                                          stb.push(b2); 

            	            }
            	            break;

            	    }


            	    match(input,SEMI,FOLLOW_SEMI_in_aexpr878); 

            	    pushFollow(FOLLOW_expr_in_aexpr882);
            	    c2=expr();

            	    state._fsp--;


            	     st.push(t3);
            	                                                                  st.push(t4);
            	                                                                  st.push(c2);
            	                                                                  stm.push(Adaptive.Modality.Must); 

            	    }
            	    break;

            	default :
            	    break loop10;
                }
            } while (true);


              // invariant: \exists k >= 0, st.size == 2 * k + 1
                                                                           val = st.pop();
                                                                           while (!st.isEmpty()) {
                                                                              Expr post_trigger = st.pop();
            	                                                                Expr pre_trigger = st.pop();
            	                                                                Expr assumption = st.pop();
            	                                                                BoundExpr bound = stb.pop(); // bound may be null
            	                                                                Adaptive.Modality mod = stm.pop();
            	                                                                val = new Adaptive(assumption,pre_trigger,post_trigger,bound,val,mod);
                                                                           }
                                                                        

            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "aexpr"



    // $ANTLR start "trigger"
    // ALTL.g:227:1: trigger returns [Expr val] : l= disjunction2 ( IMP r= disjunction2 )* ;
    public final Expr trigger() throws RecognitionException {
        Expr val = null;


        Expr l =null;

        Expr r =null;


        try {
            // ALTL.g:228:3: (l= disjunction2 ( IMP r= disjunction2 )* )
            // ALTL.g:228:3: l= disjunction2 ( IMP r= disjunction2 )*
            {
            pushFollow(FOLLOW_disjunction2_in_trigger1004);
            l=disjunction2();

            state._fsp--;


             val = l; 

            // ALTL.g:229:17: ( IMP r= disjunction2 )*
            loop11:
            do {
                int alt11=2;
                int LA11_0 = input.LA(1);

                if ( (LA11_0==IMP) ) {
                    alt11=1;
                }


                switch (alt11) {
            	case 1 :
            	    // ALTL.g:229:18: IMP r= disjunction2
            	    {
            	    match(input,IMP,FOLLOW_IMP_in_trigger1051); 

            	    pushFollow(FOLLOW_disjunction2_in_trigger1055);
            	    r=disjunction2();

            	    state._fsp--;


            	     val = new Expr2(val, BinOp.Imp, r); 

            	    }
            	    break;

            	default :
            	    break loop11;
                }
            } while (true);


            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "trigger"



    // $ANTLR start "disjunction2"
    // ALTL.g:233:1: disjunction2 returns [Expr val] : l= conjunction2 ( OR r= conjunction2 )* ;
    public final Expr disjunction2() throws RecognitionException {
        Expr val = null;


        Expr l =null;

        Expr r =null;


        try {
            // ALTL.g:234:3: (l= conjunction2 ( OR r= conjunction2 )* )
            // ALTL.g:234:3: l= conjunction2 ( OR r= conjunction2 )*
            {
            pushFollow(FOLLOW_conjunction2_in_disjunction21117);
            l=conjunction2();

            state._fsp--;


             val = l; 

            // ALTL.g:235:17: ( OR r= conjunction2 )*
            loop12:
            do {
                int alt12=2;
                int LA12_0 = input.LA(1);

                if ( (LA12_0==OR) ) {
                    alt12=1;
                }


                switch (alt12) {
            	case 1 :
            	    // ALTL.g:235:18: OR r= conjunction2
            	    {
            	    match(input,OR,FOLLOW_OR_in_disjunction21164); 

            	    pushFollow(FOLLOW_conjunction2_in_disjunction21168);
            	    r=conjunction2();

            	    state._fsp--;


            	     val = new Expr2(val, BinOp.Or, r); 

            	    }
            	    break;

            	default :
            	    break loop12;
                }
            } while (true);


            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "disjunction2"



    // $ANTLR start "conjunction2"
    // ALTL.g:239:1: conjunction2 returns [Expr val] : l= equality2 ( AND r= equality2 )* ;
    public final Expr conjunction2() throws RecognitionException {
        Expr val = null;


        Expr l =null;

        Expr r =null;


        try {
            // ALTL.g:239:32: (l= equality2 ( AND r= equality2 )* )
            // ALTL.g:240:3: l= equality2 ( AND r= equality2 )*
            {
            pushFollow(FOLLOW_equality2_in_conjunction21231);
            l=equality2();

            state._fsp--;


             val = l; 

            // ALTL.g:241:14: ( AND r= equality2 )*
            loop13:
            do {
                int alt13=2;
                int LA13_0 = input.LA(1);

                if ( (LA13_0==AND) ) {
                    alt13=1;
                }


                switch (alt13) {
            	case 1 :
            	    // ALTL.g:241:15: AND r= equality2
            	    {
            	    match(input,AND,FOLLOW_AND_in_conjunction21278); 

            	    pushFollow(FOLLOW_equality2_in_conjunction21282);
            	    r=equality2();

            	    state._fsp--;


            	     val = new Expr2(val, BinOp.And, r); 

            	    }
            	    break;

            	default :
            	    break loop13;
                }
            } while (true);


            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "conjunction2"



    // $ANTLR start "equality2"
    // ALTL.g:245:1: equality2 returns [Expr val] : ( NOT )? l= relExp2 ( eop r= relExp2 )? ;
    public final Expr equality2() throws RecognitionException {
        Expr val = null;


        Expr l =null;

        Expr r =null;

        BinOp eop4 =null;


         UnOp neg = null; 
        try {
            // ALTL.g:246:3: ( ( NOT )? l= relExp2 ( eop r= relExp2 )? )
            // ALTL.g:246:3: ( NOT )? l= relExp2 ( eop r= relExp2 )?
            {
            // ALTL.g:246:3: ( NOT )?
            int alt14=2;
            int LA14_0 = input.LA(1);

            if ( (LA14_0==NOT) ) {
                alt14=1;
            }
            switch (alt14) {
                case 1 :
                    // ALTL.g:246:4: NOT
                    {
                    match(input,NOT,FOLLOW_NOT_in_equality21356); 

                     neg = UnOp.Not ; 

                    }
                    break;

            }


            pushFollow(FOLLOW_relExp2_in_equality21407);
            l=relExp2();

            state._fsp--;


             val = l; 

            // ALTL.g:248:19: ( eop r= relExp2 )?
            int alt15=2;
            int LA15_0 = input.LA(1);

            if ( (LA15_0==EQ||LA15_0==NEQ) ) {
                alt15=1;
            }
            switch (alt15) {
                case 1 :
                    // ALTL.g:248:20: eop r= relExp2
                    {
                    pushFollow(FOLLOW_eop_in_equality21454);
                    eop4=eop();

                    state._fsp--;


                    pushFollow(FOLLOW_relExp2_in_equality21458);
                    r=relExp2();

                    state._fsp--;


                     val = new Expr2(l, eop4, r); 

                    }
                    break;

            }


             val = neg == null ? val : new Expr1(neg, val); 

            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "equality2"



    // $ANTLR start "relExp2"
    // ALTL.g:253:1: relExp2 returns [Expr val] : l= numExp2 ( rop r= numExp2 )? ;
    public final Expr relExp2() throws RecognitionException {
        Expr val = null;


        Expr l =null;

        Expr r =null;

        BinOp rop5 =null;


        try {
            // ALTL.g:254:3: (l= numExp2 ( rop r= numExp2 )? )
            // ALTL.g:254:3: l= numExp2 ( rop r= numExp2 )?
            {
            pushFollow(FOLLOW_numExp2_in_relExp21531);
            l=numExp2();

            state._fsp--;


             val = l; 

            // ALTL.g:255:12: ( rop r= numExp2 )?
            int alt16=2;
            int LA16_0 = input.LA(1);

            if ( (LA16_0==GE||LA16_0==GT||LA16_0==LE||LA16_0==LT) ) {
                alt16=1;
            }
            switch (alt16) {
                case 1 :
                    // ALTL.g:255:13: rop r= numExp2
                    {
                    pushFollow(FOLLOW_rop_in_relExp21578);
                    rop5=rop();

                    state._fsp--;


                    pushFollow(FOLLOW_numExp2_in_relExp21582);
                    r=numExp2();

                    state._fsp--;


                     val = new Expr2(l, rop5, r); 

                    }
                    break;

            }


            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "relExp2"



    // $ANTLR start "numExp2"
    // ALTL.g:260:1: numExp2 returns [Expr val] : l= term2 ( nop r= term2 )* ;
    public final Expr numExp2() throws RecognitionException {
        Expr val = null;


        Expr l =null;

        Expr r =null;

        BinOp nop6 =null;


        try {
            // ALTL.g:260:27: (l= term2 ( nop r= term2 )* )
            // ALTL.g:261:3: l= term2 ( nop r= term2 )*
            {
            pushFollow(FOLLOW_term2_in_numExp21646);
            l=term2();

            state._fsp--;


             val = l; 

            // ALTL.g:262:10: ( nop r= term2 )*
            loop17:
            do {
                int alt17=2;
                int LA17_0 = input.LA(1);

                if ( (LA17_0==ADD||LA17_0==MIN) ) {
                    alt17=1;
                }


                switch (alt17) {
            	case 1 :
            	    // ALTL.g:262:11: nop r= term2
            	    {
            	    pushFollow(FOLLOW_nop_in_numExp21693);
            	    nop6=nop();

            	    state._fsp--;


            	    pushFollow(FOLLOW_term2_in_numExp21697);
            	    r=term2();

            	    state._fsp--;


            	     val = new Expr2(val, nop6, r); 

            	    }
            	    break;

            	default :
            	    break loop17;
                }
            } while (true);


            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "numExp2"



    // $ANTLR start "term2"
    // ALTL.g:267:1: term2 returns [Expr val] : l= factor2 ( top r= factor2 )* ;
    public final Expr term2() throws RecognitionException {
        Expr val = null;


        Expr l =null;

        Expr r =null;

        BinOp top7 =null;


        try {
            // ALTL.g:268:3: (l= factor2 ( top r= factor2 )* )
            // ALTL.g:268:3: l= factor2 ( top r= factor2 )*
            {
            pushFollow(FOLLOW_factor2_in_term21760);
            l=factor2();

            state._fsp--;


             val = l; 

            // ALTL.g:269:12: ( top r= factor2 )*
            loop18:
            do {
                int alt18=2;
                int LA18_0 = input.LA(1);

                if ( (LA18_0==DIV||LA18_0==MUL) ) {
                    alt18=1;
                }


                switch (alt18) {
            	case 1 :
            	    // ALTL.g:269:13: top r= factor2
            	    {
            	    pushFollow(FOLLOW_top_in_term21807);
            	    top7=top();

            	    state._fsp--;


            	    pushFollow(FOLLOW_factor2_in_term21811);
            	    r=factor2();

            	    state._fsp--;


            	     val = new Expr2(val, top7, r); 

            	    }
            	    break;

            	default :
            	    break loop18;
                }
            } while (true);


            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "term2"



    // $ANTLR start "top2"
    // ALTL.g:273:1: top2 returns [BinOp val] : ( MUL | DIV );
    public final BinOp top2() throws RecognitionException {
        BinOp val = null;


        try {
            // ALTL.g:274:3: ( MUL | DIV )
            int alt19=2;
            int LA19_0 = input.LA(1);

            if ( (LA19_0==MUL) ) {
                alt19=1;
            }
            else if ( (LA19_0==DIV) ) {
                alt19=2;
            }
            else {
                NoViableAltException nvae =
                    new NoViableAltException("", 19, 0, input);

                throw nvae;

            }
            switch (alt19) {
                case 1 :
                    // ALTL.g:274:3: MUL
                    {
                    match(input,MUL,FOLLOW_MUL_in_top21871); 

                     val = BinOp.Mul; 

                    }
                    break;
                case 2 :
                    // ALTL.g:275:3: DIV
                    {
                    match(input,DIV,FOLLOW_DIV_in_top21893); 

                     val = BinOp.Div; 

                    }
                    break;

            }
        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "top2"



    // $ANTLR start "factor2"
    // ALTL.g:279:1: factor2 returns [Expr val] : ( MIN )? ( priority2 | (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )? | number | TRUE | FALSE ) ;
    public final Expr factor2() throws RecognitionException {
        Expr val = null;


        Token id1=null;
        Token id2=null;
        Expr priority28 =null;

        double number9 =0.0;


         UnOp neg = null; 
        try {
            // ALTL.g:280:3: ( ( MIN )? ( priority2 | (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )? | number | TRUE | FALSE ) )
            // ALTL.g:280:3: ( MIN )? ( priority2 | (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )? | number | TRUE | FALSE )
            {
            // ALTL.g:280:3: ( MIN )?
            int alt20=2;
            int LA20_0 = input.LA(1);

            if ( (LA20_0==MIN) ) {
                alt20=1;
            }
            switch (alt20) {
                case 1 :
                    // ALTL.g:280:4: MIN
                    {
                    match(input,MIN,FOLLOW_MIN_in_factor21934); 

                     neg = UnOp.Neg; 

                    }
                    break;

            }


            // ALTL.g:281:10: ( priority2 | (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )? | number | TRUE | FALSE )
            int alt23=5;
            switch ( input.LA(1) ) {
            case LP:
                {
                alt23=1;
                }
                break;
            case DQ:
            case IDENT:
                {
                alt23=2;
                }
                break;
            case DIGITS:
            case FLOATING:
                {
                alt23=3;
                }
                break;
            case TRUE:
                {
                alt23=4;
                }
                break;
            case FALSE:
                {
                alt23=5;
                }
                break;
            default:
                NoViableAltException nvae =
                    new NoViableAltException("", 23, 0, input);

                throw nvae;

            }

            switch (alt23) {
                case 1 :
                    // ALTL.g:281:12: priority2
                    {
                    pushFollow(FOLLOW_priority2_in_factor21978);
                    priority28=priority2();

                    state._fsp--;


                     val = priority28;

                    }
                    break;
                case 2 :
                    // ALTL.g:282:12: (id1= IDENT | DQ id2= IDENT DQ ) ( QUOTE )?
                    {
                    // ALTL.g:282:12: (id1= IDENT | DQ id2= IDENT DQ )
                    int alt21=2;
                    int LA21_0 = input.LA(1);

                    if ( (LA21_0==IDENT) ) {
                        alt21=1;
                    }
                    else if ( (LA21_0==DQ) ) {
                        alt21=2;
                    }
                    else {
                        NoViableAltException nvae =
                            new NoViableAltException("", 21, 0, input);

                        throw nvae;

                    }
                    switch (alt21) {
                        case 1 :
                            // ALTL.g:282:14: id1= IDENT
                            {
                            id1=(Token)match(input,IDENT,FOLLOW_IDENT_in_factor22012); 

                             val = new IdentExpr(/*gFormulaRules.modelIdMap.get*/((id1!=null?id1.getText():null))); 

                            }
                            break;
                        case 2 :
                            // ALTL.g:283:14: DQ id2= IDENT DQ
                            {
                            match(input,DQ,FOLLOW_DQ_in_factor22046); 

                            id2=(Token)match(input,IDENT,FOLLOW_IDENT_in_factor22050); 

                            match(input,DQ,FOLLOW_DQ_in_factor22052); 

                             val = new IdentExpr(/*gFormulaRules.modelIdMap.get*/("\"" + (id2!=null?id2.getText():null) + "\"")); 

                            }
                            break;

                    }


                    // ALTL.g:285:19: ( QUOTE )?
                    int alt22=2;
                    int LA22_0 = input.LA(1);

                    if ( (LA22_0==QUOTE) ) {
                        alt22=1;
                    }
                    switch (alt22) {
                        case 1 :
                            // ALTL.g:285:20: QUOTE
                            {
                            match(input,QUOTE,FOLLOW_QUOTE_in_factor22099); 

                             ((IdentExpr) val).prime = true; 

                            }
                            break;

                    }


                    }
                    break;
                case 3 :
                    // ALTL.g:287:12: number
                    {
                    pushFollow(FOLLOW_number_in_factor22152);
                    number9=number();

                    state._fsp--;


                     val = new FloatExpr(number9);

                    }
                    break;
                case 4 :
                    // ALTL.g:288:12: TRUE
                    {
                    match(input,TRUE,FOLLOW_TRUE_in_factor22185); 

                     val = new BoolExpr(true);   

                    }
                    break;
                case 5 :
                    // ALTL.g:289:12: FALSE
                    {
                    match(input,FALSE,FOLLOW_FALSE_in_factor22220); 

                     val = new BoolExpr(false);  

                    }
                    break;

            }


             val = neg == null ? val : new Expr1(neg, val);  

            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "factor2"



    // $ANTLR start "priority2"
    // ALTL.g:293:1: priority2 returns [Expr val] : LP trigger RP ;
    public final Expr priority2() throws RecognitionException {
        Expr val = null;


        Expr trigger10 =null;


        try {
            // ALTL.g:294:3: ( LP trigger RP )
            // ALTL.g:294:3: LP trigger RP
            {
            match(input,LP,FOLLOW_LP_in_priority22292); 

            pushFollow(FOLLOW_trigger_in_priority22294);
            trigger10=trigger();

            state._fsp--;


            match(input,RP,FOLLOW_RP_in_priority22296); 

             val = trigger10; 

            }

        }

            catch (RecognitionException re) {
                //displayRecognitionError(re);
                reportError(re);
                //recover(input,re);
                //throw re;
            }

        finally {
        	// do for sure before leaving
        }
        return val;
    }
    // $ANTLR end "priority2"

    // Delegated rules
    public BinOp top() throws RecognitionException { return gFormulaRules.top(); }

    public double bvalue() throws RecognitionException { return gFormulaRules.bvalue(); }

    public Expr conjunction() throws RecognitionException { return gFormulaRules.conjunction(); }

    public Expr expr() throws RecognitionException { return gFormulaRules.expr(); }

    public Range range() throws RecognitionException { return gFormulaRules.range(); }

    public void declareVars() throws RecognitionException { gFormulaRules.declareVars(); }

    public Expr implication() throws RecognitionException { return gFormulaRules.implication(); }

    public void overrideIds() throws RecognitionException { gFormulaRules.overrideIds(); }

    public Expr relExp() throws RecognitionException { return gFormulaRules.relExp(); }

    public BinOp nop() throws RecognitionException { return gFormulaRules.nop(); }

    public double number() throws RecognitionException { return gFormulaRules.number(); }

    public BoundExpr bound() throws RecognitionException { return gFormulaRules.bound(); }

    public double floating() throws RecognitionException { return gFormulaRules.floating(); }

    public Expr equality() throws RecognitionException { return gFormulaRules.equality(); }

    public BinOp rop() throws RecognitionException { return gFormulaRules.rop(); }

    public BinOp eop() throws RecognitionException { return gFormulaRules.eop(); }

    public Expr numExp() throws RecognitionException { return gFormulaRules.numExp(); }

    public Expr term() throws RecognitionException { return gFormulaRules.term(); }

    public Expr disjunction() throws RecognitionException { return gFormulaRules.disjunction(); }

    public void optimizeVars() throws RecognitionException { gFormulaRules.optimizeVars(); }

    public int integer() throws RecognitionException { return gFormulaRules.integer(); }

    public Variable variable() throws RecognitionException { return gFormulaRules.variable(); }


 

    public static final BitSet FOLLOW_MIN_in_factor76 = new BitSet(new long[]{0x0004000108524000L});
    public static final BitSet FOLLOW_LP_in_factor120 = new BitSet(new long[]{0x0004406509724000L});
    public static final BitSet FOLLOW_expr_in_factor122 = new BitSet(new long[]{0x0000800000000000L});
    public static final BitSet FOLLOW_RP_in_factor124 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENT_in_factor157 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DQ_in_factor191 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_IDENT_in_factor195 = new BitSet(new long[]{0x0000000000020000L});
    public static final BitSet FOLLOW_DQ_in_factor197 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_QUOTE_in_factor244 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_number_in_factor297 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TRUE_in_factor330 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FALSE_in_factor365 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_declareVars_in_formula455 = new BitSet(new long[]{0x0000010000040000L});
    public static final BitSet FOLLOW_optimizeVars_in_formula458 = new BitSet(new long[]{0x0000000000040000L});
    public static final BitSet FOLLOW_END_in_formula461 = new BitSet(new long[]{0x0004406509724000L});
    public static final BitSet FOLLOW_aexpr_in_formula488 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expr_in_aexpr559 = new BitSet(new long[]{0x0001008000000002L});
    public static final BitSet FOLLOW_SEMI_in_aexpr621 = new BitSet(new long[]{0x0000000020000000L});
    public static final BitSet FOLLOW_LB_in_aexpr623 = new BitSet(new long[]{0x0004004508524000L});
    public static final BitSet FOLLOW_trigger_in_aexpr627 = new BitSet(new long[]{0x0000000000000400L});
    public static final BitSet FOLLOW_COMMA_in_aexpr629 = new BitSet(new long[]{0x0004004508524000L});
    public static final BitSet FOLLOW_trigger_in_aexpr633 = new BitSet(new long[]{0x0000100000000000L});
    public static final BitSet FOLLOW_RB_in_aexpr636 = new BitSet(new long[]{0x0000008080000000L});
    public static final BitSet FOLLOW_bound_in_aexpr664 = new BitSet(new long[]{0x0000008000000000L});
    public static final BitSet FOLLOW_OCCURS_in_aexpr726 = new BitSet(new long[]{0x0004406509724000L});
    public static final BitSet FOLLOW_expr_in_aexpr730 = new BitSet(new long[]{0x0001008000000002L});
    public static final BitSet FOLLOW_OCCURS_in_aexpr777 = new BitSet(new long[]{0x0000000020000000L});
    public static final BitSet FOLLOW_LB_in_aexpr779 = new BitSet(new long[]{0x0004004508524000L});
    public static final BitSet FOLLOW_trigger_in_aexpr783 = new BitSet(new long[]{0x0000000000000400L});
    public static final BitSet FOLLOW_COMMA_in_aexpr785 = new BitSet(new long[]{0x0004004508524000L});
    public static final BitSet FOLLOW_trigger_in_aexpr789 = new BitSet(new long[]{0x0000100000000000L});
    public static final BitSet FOLLOW_RB_in_aexpr792 = new BitSet(new long[]{0x0001000080000000L});
    public static final BitSet FOLLOW_bound_in_aexpr817 = new BitSet(new long[]{0x0001000000000000L});
    public static final BitSet FOLLOW_SEMI_in_aexpr878 = new BitSet(new long[]{0x0004406509724000L});
    public static final BitSet FOLLOW_expr_in_aexpr882 = new BitSet(new long[]{0x0001008000000002L});
    public static final BitSet FOLLOW_disjunction2_in_trigger1004 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_IMP_in_trigger1051 = new BitSet(new long[]{0x0004004508524000L});
    public static final BitSet FOLLOW_disjunction2_in_trigger1055 = new BitSet(new long[]{0x0000000010000002L});
    public static final BitSet FOLLOW_conjunction2_in_disjunction21117 = new BitSet(new long[]{0x0000020000000002L});
    public static final BitSet FOLLOW_OR_in_disjunction21164 = new BitSet(new long[]{0x0004004508524000L});
    public static final BitSet FOLLOW_conjunction2_in_disjunction21168 = new BitSet(new long[]{0x0000020000000002L});
    public static final BitSet FOLLOW_equality2_in_conjunction21231 = new BitSet(new long[]{0x0000000000000042L});
    public static final BitSet FOLLOW_AND_in_conjunction21278 = new BitSet(new long[]{0x0004004508524000L});
    public static final BitSet FOLLOW_equality2_in_conjunction21282 = new BitSet(new long[]{0x0000000000000042L});
    public static final BitSet FOLLOW_NOT_in_equality21356 = new BitSet(new long[]{0x0004000508524000L});
    public static final BitSet FOLLOW_relExp2_in_equality21407 = new BitSet(new long[]{0x0000001000080002L});
    public static final BitSet FOLLOW_eop_in_equality21454 = new BitSet(new long[]{0x0004000508524000L});
    public static final BitSet FOLLOW_relExp2_in_equality21458 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_numExp2_in_relExp21531 = new BitSet(new long[]{0x0000000282800002L});
    public static final BitSet FOLLOW_rop_in_relExp21578 = new BitSet(new long[]{0x0004000508524000L});
    public static final BitSet FOLLOW_numExp2_in_relExp21582 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_term2_in_numExp21646 = new BitSet(new long[]{0x0000000400000012L});
    public static final BitSet FOLLOW_nop_in_numExp21693 = new BitSet(new long[]{0x0004000508524000L});
    public static final BitSet FOLLOW_term2_in_numExp21697 = new BitSet(new long[]{0x0000000400000012L});
    public static final BitSet FOLLOW_factor2_in_term21760 = new BitSet(new long[]{0x0000000800008002L});
    public static final BitSet FOLLOW_top_in_term21807 = new BitSet(new long[]{0x0004000508524000L});
    public static final BitSet FOLLOW_factor2_in_term21811 = new BitSet(new long[]{0x0000000800008002L});
    public static final BitSet FOLLOW_MUL_in_top21871 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DIV_in_top21893 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_MIN_in_factor21934 = new BitSet(new long[]{0x0004000108524000L});
    public static final BitSet FOLLOW_priority2_in_factor21978 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_IDENT_in_factor22012 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_DQ_in_factor22046 = new BitSet(new long[]{0x0000000008000000L});
    public static final BitSet FOLLOW_IDENT_in_factor22050 = new BitSet(new long[]{0x0000000000020000L});
    public static final BitSet FOLLOW_DQ_in_factor22052 = new BitSet(new long[]{0x0000080000000002L});
    public static final BitSet FOLLOW_QUOTE_in_factor22099 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_number_in_factor22152 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_TRUE_in_factor22185 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_FALSE_in_factor22220 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_LP_in_priority22292 = new BitSet(new long[]{0x0004004508524000L});
    public static final BitSet FOLLOW_trigger_in_priority22294 = new BitSet(new long[]{0x0000800000000000L});
    public static final BitSet FOLLOW_RP_in_priority22296 = new BitSet(new long[]{0x0000000000000002L});

}