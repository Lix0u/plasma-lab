<?xml version="1.0" encoding="UTF-8"?>
<PlasmaProject name="Synchronous Leader Election Protocol">
  <models>
    <model name="leader_sync3_2.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 3; // number of processes
const K = 2; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3;</content>
    </model>
    <model name="leader_sync3_3.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 3; // number of processes
const K = 3; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3;</content>
    </model>
    <model name="leader_sync3_4.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 3; // number of processes
const K = 4; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3;</content>
    </model>
    <model name="leader_sync3_5.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 3; // number of processes
const K = 5; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3;</content>
    </model>
    <model name="leader_sync3_6.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 3; // number of processes
const K = 6; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=5) &amp; (v1'=5) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3;</content>
    </model>
    <model name="leader_sync3_8.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 3; // number of processes
const K = 8; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=5) &amp; (v1'=5) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=6) &amp; (v1'=6) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=7) &amp; (v1'=7) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3;</content>
    </model>
    <model name="leader_sync4_2.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 4; // number of processes
const K = 2; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3;</content>
    </model>
    <model name="leader_sync4_3.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 4; // number of processes
const K = 3; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3;</content>
    </model>
    <model name="leader_sync4_4.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 4; // number of processes
const K = 4; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3;</content>
    </model>
    <model name="leader_sync4_5.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 4; // number of processes
const K = 5; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3;</content>
    </model>
    <model name="leader_sync4_6.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 4; // number of processes
const K = 6; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=5) &amp; (v1'=5) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3;</content>
    </model>
    <model name="leader_sync4_8.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 4; // number of processes
const K = 8; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=5) &amp; (v1'=5) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=6) &amp; (v1'=6) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=7) &amp; (v1'=7) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3;</content>
    </model>
    <model name="leader_sync5_2.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 5; // number of processes
const K = 2; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3;</content>
    </model>
    <model name="leader_sync5_3.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 5; // number of processes
const K = 3; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3;</content>
    </model>
    <model name="leader_sync5_4.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 5; // number of processes
const K = 4; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3;</content>
    </model>
    <model name="leader_sync5_5.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 5; // number of processes
const K = 5; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3;</content>
    </model>
    <model name="leader_sync5_6.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 5; // number of processes
const K = 6; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=5) &amp; (v1'=5) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3;</content>
    </model>
    <model name="leader_sync5_8.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 5; // number of processes
const K = 8; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=5) &amp; (v1'=5) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=6) &amp; (v1'=6) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=7) &amp; (v1'=7) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3;</content>
    </model>
    <model name="leader_sync6_2.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 6; // number of processes
const K = 2; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5|u6 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5|u6) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v6 ] endmodule
module process6 = process1 [ s1=s6,p1=p6,v1=v6,u1=u6,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3&amp;s6=3;</content>
    </model>
    <model name="leader_sync6_3.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 6; // number of processes
const K = 3; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5|u6 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5|u6) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v6 ] endmodule
module process6 = process1 [ s1=s6,p1=p6,v1=v6,u1=u6,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3&amp;s6=3;</content>
    </model>
    <model name="leader_sync6_4.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 6; // number of processes
const K = 4; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5|u6 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5|u6) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v6 ] endmodule
module process6 = process1 [ s1=s6,p1=p6,v1=v6,u1=u6,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3&amp;s6=3;</content>
    </model>
    <model name="leader_sync6_5.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 6; // number of processes
const K = 5; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5|u6 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5|u6) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v6 ] endmodule
module process6 = process1 [ s1=s6,p1=p6,v1=v6,u1=u6,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3&amp;s6=3;</content>
    </model>
    <model name="leader_sync6_6.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 6; // number of processes
const K = 6; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5|u6 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5|u6) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=5) &amp; (v1'=5) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v6 ] endmodule
module process6 = process1 [ s1=s6,p1=p6,v1=v6,u1=u6,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3&amp;s6=3;</content>
    </model>
    <model name="leader_sync6_8.pm" type="rml">
      <content>// synchronous leader election protocol  (itai &amp; Rodeh)
// dxp/gxn 25/01/01

dtmc

// CONSTANTS
const N = 6; // number of processes
const K = 8; // range of probabilistic choice

// counter module used to count the number of processes that have been read
// and to know when a process has decided
module counter
	
	// counter (c=i  means process j reading process (i-1)+j next)
	c : [1..N-1];
	
	// reading
	[read] c&lt;N-1 -&gt; (c'=c+1);
	// finished reading
	[read] c=N-1 -&gt; (c'=c);
	//decide
	[done] u1|u2|u3|u4|u5|u6 -&gt; (c'=c);
	// pick again reset counter 
	[retry] !(u1|u2|u3|u4|u5|u6) -&gt; (c'=1);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (c'=c);
	
endmodule

//  processes form a ring and suppose:
// process 1 reads process 2
// process 2 reads process 3
// process 3 reads process 1
module process1
	
	// local state
	s1 : [0..3];
	// s1=0 make random choice
	// s1=1 reading
	// s1=2 deciding
	// s1=3 finished
	
	// has a unique id so far (initially true)
	u1 : bool;
	
	// value to be sent to next process in the ring (initially sets this to its own value)
	v1 : [0..K-1];
	
	// random choice
	p1 : [0..K-1];
	
	// pick value
	[pick] s1=0 -&gt; 1/K : (s1'=1) &amp; (p1'=0) &amp; (v1'=0) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=1) &amp; (v1'=1) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=2) &amp; (v1'=2) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=3) &amp; (v1'=3) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=4) &amp; (v1'=4) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=5) &amp; (v1'=5) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=6) &amp; (v1'=6) &amp; (u1'=true)
	             + 1/K : (s1'=1) &amp; (p1'=7) &amp; (v1'=7) &amp; (u1'=true);
	// read
	[read] s1=1 &amp;  u1 &amp; c&lt;N-1 -&gt; (u1'=(p1!=v2)) &amp; (v1'=v2);
	[read] s1=1 &amp; !u1 &amp; c&lt;N-1 -&gt; (u1'=false) &amp; (v1'=v2) &amp; (p1'=0);
	// read and move to decide
	[read] s1=1 &amp;  u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=(p1!=v2)) &amp; (v1'=0) &amp; (p1'=0);
	[read] s1=1 &amp; !u1 &amp; c=N-1 -&gt; (s1'=2) &amp; (u1'=false) &amp; (v1'=0);
	// deciding
	// done
	[done] s1=2 -&gt; (s1'=3) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	//retry
	[retry] s1=2 -&gt; (s1'=0) &amp; (u1'=false) &amp; (v1'=0) &amp; (p1'=0);
	// loop (when finished to avoid deadlocks)
	[loop] s1=3 -&gt; (s1'=3);
	
endmodule

// construct remaining processes through renaming
module process2 = process1 [ s1=s2,p1=p2,v1=v2,u1=u2,v2=v3 ] endmodule
module process3 = process1 [ s1=s3,p1=p3,v1=v3,u1=u3,v2=v4 ] endmodule
module process4 = process1 [ s1=s4,p1=p4,v1=v4,u1=u4,v2=v5 ] endmodule
module process5 = process1 [ s1=s5,p1=p5,v1=v5,u1=u5,v2=v6 ] endmodule
module process6 = process1 [ s1=s6,p1=p6,v1=v6,u1=u6,v2=v1 ] endmodule

// expected number of rounds
rewards "num_rounds"
	[pick] true : 1;
endrewards

// labels
label "elected" = s1=3&amp;s2=3&amp;s3=3&amp;s4=3&amp;s5=3&amp;s6=3;</content>
    </model>
  </models>
  <requirements>
    <requirement name="elected" type="bltl">
      <content>declare
L := [1;15;1]
end

F&lt;=#(L*(N+1)) "elected"</content>
    </requirement>
  </requirements>
</PlasmaProject>
