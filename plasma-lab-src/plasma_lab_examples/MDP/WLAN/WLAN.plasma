<?xml version="1.0" encoding="UTF-8"?>
<PlasmaProject name="WLAN">
  <models>
    <model name="wlan_0" type="rml">
      <content>// WLAN PROTOCOL (two stations)
// discrete time model
// gxn/jzs 20/02/02

mdp

// COLLISIONS
const int COL=2; // maximum number of collisions

// TIMING CONSTRAINTS
// we have used the FHSS parameters
// then scaled by the value of ASLOTTIME
const ASLOTTIME = 1;
const DIFS = 3; // due to scaling can be either 2 or 3 which is modelled by a non-deterministic choice
const VULN = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
const TRANS_TIME_MAX = 10; // scaling up
const TRANS_TIME_MIN = 4; // scaling down
const ACK_TO = 6; 
const ACK = 4; // due to scaling can be either 3 or 4 which is modelled by a non-deterministic choice
const SIFS = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
// maximum constant used in timing constraints + 1
const TIME_MAX = max(ACK_TO,TRANS_TIME_MAX)+1;

// CONTENTION WINDOW
// CWMIN =15 &amp; CWMAX =16
// this means that MAX_BACKOFF IS 2
const MAX_BACKOFF = 0;

//-----------------------------------------------------------------//
// THE MEDIUM/CHANNEL

// FORMULAE FOR THE CHANNEL
// channel is busy
formula busy = c1&gt;0 | c2&gt;0;
// channel is free
formula free = c1=0 &amp; c2=0;

module medium
	
	// number of collisions
	col : [0..COL+1];
	
	// medium status 
	c1 : [0..2];
	c2 : [0..2];
	// ci corresponds to messages associated with station i
	// 0 nothing being sent
	// 1 being sent correctly
	// 2 being sent garbled	  
	
	// begin sending message and nothing else currently being sent
	[send1] c1=0 &amp; c2=0 -&gt; (c1'=1);
	[send2] c2=0 &amp; c1=0 -&gt; (c2'=1);
	
	// begin sending message and  something is already being sent
	// in this case both messages become garbled
	[send1] c1=0 &amp; c2&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	[send2] c2=0 &amp; c1&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	
	// finish sending message
	[finish1] c1&gt;0 -&gt; (c1'=0);
	[finish2] c2&gt;0 -&gt; (c2'=0);

endmodule

//-----------------------------------------------------------------//
// STATION 1
module station1
	// clock for station 1
	x1 : [0..TIME_MAX];
	
	// local state
	s1 : [1..12];
	// 1 sense
	// 2 wait until free before setting backoff
	// 3 wait for DIFS then set slot
	// 4 set backoff 
	// 5 backoff
	// 6 wait until free in backoff
	// 7 wait for DIFS then resume backoff
	// 8 vulnerable 
	// 9 transmit
	// 11 wait for SIFS and then ACK
	// 10 wait for ACT_TO 
	// 12 done
	// BACKOFF
	// separate into slots
	slot1 : [0..1]; 
	backoff1 : [0..15];
	
	// BACKOFF COUNTER
	bc1 : [0..1];
	// SENSE
	// let time pass
	[time] s1=1 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// ready to transmit
	[] s1=1 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy so wait until free
	[] s1=1 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// WAIT UNTIL FREE BEFORE SETTING BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=2 &amp; busy -&gt; (s1'=2);
	// find that channel is free so check its free for DIFS before setting backoff
	[] s1=2 &amp; free -&gt; (s1'=3);
	// WAIT FOR DIFS THEN SET BACKOFF
	// let time pass
	[time] s1=3 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// found channel busy so wait until free
	[] s1=3 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// start backoff  first uniformly choose slot
	// backoff counter 0
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=0 -&gt; (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// SET BACKOFF (no time can pass)
	// chosen slot now set backoff
	[] s1=4 -&gt; 1/16 : (s1'=5) &amp; (backoff1'=0 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=1 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=2 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=3 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=4 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=5 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=6 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=7 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=8 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=9 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=10)
	         + 1/16 : (s1'=5) &amp; (backoff1'=11)
	         + 1/16 : (s1'=5) &amp; (backoff1'=12)
	         + 1/16 : (s1'=5) &amp; (backoff1'=13)
	         + 1/16 : (s1'=5) &amp; (backoff1'=14)
	         + 1/16 : (s1'=5) &amp; (backoff1'=15);
	// BACKOFF
	// let time pass
	[time] s1=5 &amp; x1&lt;ASLOTTIME &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// decrement backoff
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=backoff1-1);	
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=15) &amp; (slot1'=slot1-1);	
	// finish backoff 
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1=0 -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy
	[] s1=5 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	// WAIT UNTIL FREE IN BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=6 &amp; busy -&gt; (s1'=6);
	// find that channel is free
	[] s1=6 &amp; free -&gt; (s1'=7);
	
	// WAIT FOR DIFS THEN RESUME BACKOFF
	// let time pass
	[time] s1=7 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// resume backoff (start again from previous backoff)
	[] s1=7 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=5) &amp; (x1'=0);
	// found channel busy
	[] s1=7 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	
	// VULNERABLE
	// let time pass
	[time] s1=8 &amp; x1&lt;VULN -&gt; (x1'=min(x1+1,TIME_MAX));
	// move to transmit
	[send1] s1=8 &amp; (x1=VULN | x1=VULN-1) -&gt; (s1'=9) &amp; (x1'=0);
	// TRANSMIT
	// let time pass
	[time] s1=9 &amp; x1&lt;TRANS_TIME_MAX -&gt; (x1'=min(x1+1,TIME_MAX));
	// finish transmission successful	
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=1 -&gt; (s1'=10) &amp; (x1'=0);
	// finish transmission garbled
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=2 -&gt; (s1'=11) &amp; (x1'=0);
	// WAIT FOR SIFS THEN WAIT FOR ACK
	
	// WAIT FOR SIFS i.e. c1=0
	// check channel and busy: go into backoff
	[] s1=10 &amp; c1=0 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=10 &amp; c1=0 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	// following guard is always false as SIFS=1
	// [time] s1=10 &amp; c1=0 &amp; x1&gt;0 &amp; x1&lt;SIFS -&gt; (x1'=min(x1+1,TIME_MAX));
	// ack is sent after SIFS (since SIFS-1=0 add condition that channel is free)
	[send1] s1=10 &amp; c1=0 &amp; (x1=SIFS | (x1=SIFS-1 &amp; free)) -&gt; (s1'=10) &amp; (x1'=0);
	
	// WAIT FOR ACK i.e. c1=1
	// let time pass
	[time] s1=10 &amp; c1=1 &amp; x1&lt;ACK -&gt; (x1'=min(x1+1,TIME_MAX));
	// get acknowledgement so packet sent correctly and move to done
	[finish1] s1=10 &amp; c1=1 &amp; (x1=ACK | x1=ACK-1) -&gt; (s1'=12) &amp; (x1'=0) &amp; (bc1'=0);
	
	// WAIT FOR ACK_TO
	// check channel and busy: go into backoff
	[] s1=11 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=11 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	[time] s1=11 &amp; x1&gt;0 &amp; x1&lt;ACK_TO -&gt; (x1'=min(x1+1,TIME_MAX));
	// no acknowledgement (go to backoff waiting DIFS first)
	[] s1=11 &amp; x1=ACK_TO -&gt; (s1'=3) &amp; (x1'=0);
		
	// DONE
	[time] s1=12 -&gt; (s1'=12);

endmodule	

// ---------------------------------------------------------------------------- //
// STATION 2 (rename STATION 1)
module 
station2=station1[x1=x2, 
                  s1=s2,
				  s2=s1,
				  c1=c2,
				  c2=c1, 
				  slot1=slot2, 
				  backoff1=backoff2, 
				  bc1=bc2, 
				  send1=send2, 
				  finish1=finish2] 
endmodule
// ---------------------------------------------------------------------------- //

// reward structures

// number of collisions
rewards "collisions"
	[send1] c1=0 &amp; c2&gt;0 : 1; // station one starts transmitting and station two is already transmitting
	[send2] c2=0 &amp; c1&gt;0 : 1; // station two starts transmitting and station one is already transmitting
endrewards

// reward structure for expected time
// recall one time unit equals ASLOT(=50{\mu}s)
rewards "time"
	[time] true : 50;
endrewards

// reward strcuture for expected cost
// cost (per time unit) is set to:
// 1 in locations where the channel is free,
// 10 in locations where the channel is in use and a message is being sent correctly
// 1000 in locations where a station is sending a garbled message
// 2000 in locations where both stations are sending garbled messages
rewards	"cost"
	[time] c1=0 &amp; c2=0 : 50;
	[time] c1+c2=1 : 50*10;
	[time] c1=1 &amp; c2=1 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=0 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=0 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*2000;
endrewards</content>
    </model>
    <model name="wlan_1" type="rml">
      <content>// WLAN PROTOCOL (two stations)
// discrete time model
// gxn/jzs 20/02/02

mdp

// COLLISIONS
const int COL=2; // maximum number of collisions

// TIMING CONSTRAINTS
// we have used the FHSS parameters
// then scaled by the value of ASLOTTIME
const ASLOTTIME = 1;
const DIFS = 3; // due to scaling can be either 2 or 3 which is modelled by a non-deterministic choice
const VULN = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
const TRANS_TIME_MAX = 10; // scaling up
const TRANS_TIME_MIN = 4; // scaling down
const ACK_TO = 6; 
const ACK = 4; // due to scaling can be either 3 or 4 which is modelled by a non-deterministic choice
const SIFS = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
// maximum constant used in timing constraints + 1
const TIME_MAX = max(ACK_TO,TRANS_TIME_MAX)+1;

// CONTENTION WINDOW
// CWMIN =15 &amp; CWMAX =31
// this means that MAX_BACKOFF IS 2
const MAX_BACKOFF = 1;

//-----------------------------------------------------------------//
// THE MEDIUM/CHANNEL

// FORMULAE FOR THE CHANNEL
// channel is busy
formula busy = c1&gt;0 | c2&gt;0;
// channel is free
formula free = c1=0 &amp; c2=0;

module medium
	
	// number of collisions
	col : [0..COL+1];
	
	// medium status 
	c1 : [0..2];
	c2 : [0..2];
	// ci corresponds to messages associated with station i
	// 0 nothing being sent
	// 1 being sent correctly
	// 2 being sent garbled	  
	
	// begin sending message and nothing else currently being sent
	[send1] c1=0 &amp; c2=0 -&gt; (c1'=1);
	[send2] c2=0 &amp; c1=0 -&gt; (c2'=1);
	
	// begin sending message and  something is already being sent
	// in this case both messages become garbled
	[send1] c1=0 &amp; c2&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	[send2] c2=0 &amp; c1&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	
	// finish sending message
	[finish1] c1&gt;0 -&gt; (c1'=0);
	[finish2] c2&gt;0 -&gt; (c2'=0);

endmodule

//-----------------------------------------------------------------//
// STATION 1
module station1
	// clock for station 1
	x1 : [0..TIME_MAX];
	
	// local state
	s1 : [1..12];
	// 1 sense
	// 2 wait until free before setting backoff
	// 3 wait for DIFS then set slot
	// 4 set backoff 
	// 5 backoff
	// 6 wait until free in backoff
	// 7 wait for DIFS then resume backoff
	// 8 vulnerable 
	// 9 transmit
	// 11 wait for SIFS and then ACK
	// 10 wait for ACT_TO 
	// 12 done
	// BACKOFF
	// separate into slots
	slot1 : [0..1]; 
	backoff1 : [0..15];
	
	// BACKOFF COUNTER
	bc1 : [0..MAX_BACKOFF];
	// SENSE
	// let time pass
	[time] s1=1 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// ready to transmit
	[] s1=1 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy so wait until free
	[] s1=1 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// WAIT UNTIL FREE BEFORE SETTING BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=2 &amp; busy -&gt; (s1'=2);
	// find that channel is free so check its free for DIFS before setting backoff
	[] s1=2 &amp; free -&gt; (s1'=3);
	// WAIT FOR DIFS THEN SET BACKOFF
	// let time pass
	[time] s1=3 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// found channel busy so wait until free
	[] s1=3 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// start backoff  first uniformly choose slot
	// backoff counter 0
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=0 -&gt; (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 1
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=1 -&gt; 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// SET BACKOFF (no time can pass)
	// chosen slot now set backoff
	[] s1=4 -&gt; 1/16 : (s1'=5) &amp; (backoff1'=0 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=1 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=2 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=3 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=4 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=5 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=6 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=7 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=8 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=9 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=10)
	         + 1/16 : (s1'=5) &amp; (backoff1'=11)
	         + 1/16 : (s1'=5) &amp; (backoff1'=12)
	         + 1/16 : (s1'=5) &amp; (backoff1'=13)
	         + 1/16 : (s1'=5) &amp; (backoff1'=14)
	         + 1/16 : (s1'=5) &amp; (backoff1'=15);
	// BACKOFF
	// let time pass
	[time] s1=5 &amp; x1&lt;ASLOTTIME &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// decrement backoff
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=backoff1-1);	
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=15) &amp; (slot1'=slot1-1);	
	// finish backoff 
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1=0 -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy
	[] s1=5 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	// WAIT UNTIL FREE IN BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=6 &amp; busy -&gt; (s1'=6);
	// find that channel is free
	[] s1=6 &amp; free -&gt; (s1'=7);
	
	// WAIT FOR DIFS THEN RESUME BACKOFF
	// let time pass
	[time] s1=7 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// resume backoff (start again from previous backoff)
	[] s1=7 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=5) &amp; (x1'=0);
	// found channel busy
	[] s1=7 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	
	// VULNERABLE
	// let time pass
	[time] s1=8 &amp; x1&lt;VULN -&gt; (x1'=min(x1+1,TIME_MAX));
	// move to transmit
	[send1] s1=8 &amp; (x1=VULN | x1=VULN-1) -&gt; (s1'=9) &amp; (x1'=0);
	// TRANSMIT
	// let time pass
	[time] s1=9 &amp; x1&lt;TRANS_TIME_MAX -&gt; (x1'=min(x1+1,TIME_MAX));
	// finish transmission successful	
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=1 -&gt; (s1'=10) &amp; (x1'=0);
	// finish transmission garbled
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=2 -&gt; (s1'=11) &amp; (x1'=0);
	// WAIT FOR SIFS THEN WAIT FOR ACK
	
	// WAIT FOR SIFS i.e. c1=0
	// check channel and busy: go into backoff
	[] s1=10 &amp; c1=0 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// chEck channel and free: let time pass
	[time] s1=10 &amp; c1=0 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	// following guard is always false as SIFS=1
	// [time] s1=10 &amp; c1=0 &amp; x1&gt;0 &amp; x1&lt;SIFS -&gt; (x1'=min(x1+1,TIME_MAX));
	// ack is sent after SIFS (since SIFS-1=0 add condition that channel is free)
	[send1] s1=10 &amp; c1=0 &amp; (x1=SIFS | (x1=SIFS-1 &amp; free)) -&gt; (s1'=10) &amp; (x1'=0);
	
	// WAIT FOR ACK i.e. c1=1
	// let time pass
	[time] s1=10 &amp; c1=1 &amp; x1&lt;ACK -&gt; (x1'=min(x1+1,TIME_MAX));
	// get acknowledgement so packet sent correctly and move to done
	[finish1] s1=10 &amp; c1=1 &amp; (x1=ACK | x1=ACK-1) -&gt; (s1'=12) &amp; (x1'=0) &amp; (bc1'=0);
	
	// WAIT FOR ACK_TO
	// check channel and busy: go into backoff
	[] s1=11 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=11 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	[time] s1=11 &amp; x1&gt;0 &amp; x1&lt;ACK_TO -&gt; (x1'=min(x1+1,TIME_MAX));
	// no acknowledgement (go to backoff waiting DIFS first)
	[] s1=11 &amp; x1=ACK_TO -&gt; (s1'=3) &amp; (x1'=0);
		
	// DONE
	[time] s1=12 -&gt; (s1'=12);
endmodule	

// ---------------------------------------------------------------------------- //
// STATION 2 (rename STATION 1)
module 
station2=station1[x1=x2, 
                  s1=s2,
				  s2=s1,
				  c1=c2,
				  c2=c1, 
				  slot1=slot2, 
				  backoff1=backoff2, 
				  bc1=bc2, 
				  send1=send2, 
				  finish1=finish2] 
endmodule
// ---------------------------------------------------------------------------- //

// reward structures

// number of collisions
rewards "collisions"
	[send1] c1=0 &amp; c2&gt;0 : 1; // station one starts transmitting and station two is already transmitting
	[send2] c2=0 &amp; c1&gt;0 : 1; // station two starts transmitting and station one is already transmitting
endrewards

// reward structure for expected time
// recall one time unit equals ASLOT(=50{\mu}s)
rewards "time"
	[time] true : 50;
endrewards

// reward strcuture for expected cost
// cost (per time unit) is set to:
// 1 in locations where the channel is free,
// 10 in locations where the channel is in use and a message is being sent correctly
// 1000 in locations where a station is sending a garbled message
// 2000 in locations where both stations are sending garbled messages
rewards	"cost"
	[time] c1=0 &amp; c2=0 : 50;
	[time] c1+c2=1 : 50*10;
	[time] c1=1 &amp; c2=1 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=0 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=0 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*2000;
endrewards</content>
    </model>
    <model name="wlan_2" type="rml">
      <content>// WLAN PROTOCOL (two stations)
// discrete time model
// gxn/jzs 20/02/02

mdp

// COLLISIONS
const int COL=2; // maximum number of collisions

// TIMING CONSTRAINTS
// we have used the FHSS parameters
// then scaled by the value of ASLOTTIME
const ASLOTTIME = 1;
const DIFS = 3; // due to scaling can be either 2 or 3 which is modelled by a non-deterministic choice
const VULN = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
const TRANS_TIME_MAX = 10; // scaling up
const TRANS_TIME_MIN = 4; // scaling down
const ACK_TO = 6; 
const ACK = 4; // due to scaling can be either 3 or 4 which is modelled by a non-deterministic choice
const SIFS = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
// maximum constant used in timing constraints + 1
const TIME_MAX = max(ACK_TO,TRANS_TIME_MAX)+1;

// CONTENTION WINDOW
// CWMIN =15 &amp; CWMAX =63
// this means that MAX_BACKOFF IS 2
const MAX_BACKOFF = 2;

//-----------------------------------------------------------------//
// THE MEDIUM/CHANNEL

// FORMULAE FOR THE CHANNEL
// channel is busy
formula busy = c1&gt;0 | c2&gt;0;
// channel is free
formula free = c1=0 &amp; c2=0;

module medium
	
	// number of collisions
	col : [0..COL+1];
	
	// medium status 
	c1 : [0..2];
	c2 : [0..2];
	// ci corresponds to messages associated with station i
	// 0 nothing being sent
	// 1 being sent correctly
	// 2 being sent garbled	  
	
	// begin sending message and nothing else currently being sent
	[send1] c1=0 &amp; c2=0 -&gt; (c1'=1);
	[send2] c2=0 &amp; c1=0 -&gt; (c2'=1);
	
	// begin sending message and  something is already being sent
	// in this case both messages become garbled
	[send1] c1=0 &amp; c2&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	[send2] c2=0 &amp; c1&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	
	// finish sending message
	[finish1] c1&gt;0 -&gt; (c1'=0);
	[finish2] c2&gt;0 -&gt; (c2'=0);

endmodule

//-----------------------------------------------------------------//
// STATION 1
module station1
	// clock for station 1
	x1 : [0..TIME_MAX];
	
	// local state
	s1 : [1..12];
	// 1 sense
	// 2 wait until free before setting backoff
	// 3 wait for DIFS then set slot
	// 4 set backoff 
	// 5 backoff
	// 6 wait until free in backoff
	// 7 wait for DIFS then resume backoff
	// 8 vulnerable 
	// 9 transmit
	// 11 wait for SIFS and then ACK
	// 10 wait for ACT_TO 
	// 12 done
	// BACKOFF
	// separate into slots
	slot1 : [0..3]; 
	backoff1 : [0..15];
	
	// BACKOFF COUNTER
	bc1 : [0..MAX_BACKOFF];
	// SENSE
	// let time pass
	[time] s1=1 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// ready to transmit
	[] s1=1 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy so wait until free
	[] s1=1 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// WAIT UNTIL FREE BEFORE SETTING BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=2 &amp; busy -&gt; (s1'=2);
	// find that channel is free so check its free for DIFS before setting backoff
	[] s1=2 &amp; free -&gt; (s1'=3);
	// WAIT FOR DIFS THEN SET BACKOFF
	// let time pass
	[time] s1=3 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// found channel busy so wait until free
	[] s1=3 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// start backoff  first uniformly choose slot
	// backoff counter 0
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=0 -&gt; (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 1
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=1 -&gt; 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 2
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=2 -&gt; 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// SET BACKOFF (no time can pass)
	// chosen slot now set backoff
	[] s1=4 -&gt; 1/16 : (s1'=5) &amp; (backoff1'=0 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=1 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=2 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=3 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=4 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=5 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=6 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=7 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=8 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=9 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=10)
	         + 1/16 : (s1'=5) &amp; (backoff1'=11)
	         + 1/16 : (s1'=5) &amp; (backoff1'=12)
	         + 1/16 : (s1'=5) &amp; (backoff1'=13)
	         + 1/16 : (s1'=5) &amp; (backoff1'=14)
	         + 1/16 : (s1'=5) &amp; (backoff1'=15);
	// BACKOFF
	// let time pass
	[time] s1=5 &amp; x1&lt;ASLOTTIME &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// decrement backoff
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=backoff1-1);	
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=15) &amp; (slot1'=slot1-1);	
	// finish backoff 
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1=0 -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy
	[] s1=5 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	// WAIT UNTIL FREE IN BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=6 &amp; busy -&gt; (s1'=6);
	// find that channel is free
	[] s1=6 &amp; free -&gt; (s1'=7);
	
	// WAIT FOR DIFS THEN RESUME BACKOFF
	// let time pass
	[time] s1=7 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// resume backoff (start again from previous backoff)
	[] s1=7 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=5) &amp; (x1'=0);
	// found channel busy
	[] s1=7 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	
	// VULNERABLE
	// let time pass
	[time] s1=8 &amp; x1&lt;VULN -&gt; (x1'=min(x1+1,TIME_MAX));
	// move to transmit
	[send1] s1=8 &amp; (x1=VULN | x1=VULN-1) -&gt; (s1'=9) &amp; (x1'=0);
	// TRANSMIT
	// let time pass
	[time] s1=9 &amp; x1&lt;TRANS_TIME_MAX -&gt; (x1'=min(x1+1,TIME_MAX));
	// finish transmission successful	
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=1 -&gt; (s1'=10) &amp; (x1'=0);
	// finish transmission garbled
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=2 -&gt; (s1'=11) &amp; (x1'=0);
	// WAIT FOR SIFS THEN WAIT FOR ACK
	
	// WAIT FOR SIFS i.e. c1=0
	// check channel and busy: go into backoff
	[] s1=10 &amp; c1=0 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=10 &amp; c1=0 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	// following guard is always false as SIFS=1
	// [time] s1=10 &amp; c1=0 &amp; x1&gt;0 &amp; x1&lt;SIFS -&gt; (x1'=min(x1+1,TIME_MAX));
	// ack is sent after SIFS (since SIFS-1=0 add condition that channel is free)
	[send1] s1=10 &amp; c1=0 &amp; (x1=SIFS | (x1=SIFS-1 &amp; free)) -&gt; (s1'=10) &amp; (x1'=0);
	
	// WAIT FOR ACK i.e. c1=1
	// let time pass
	[time] s1=10 &amp; c1=1 &amp; x1&lt;ACK -&gt; (x1'=min(x1+1,TIME_MAX));
	// get acknowledgement so packet sent correctly and move to done
	[finish1] s1=10 &amp; c1=1 &amp; (x1=ACK | x1=ACK-1) -&gt; (s1'=12) &amp; (x1'=0) &amp; (bc1'=0);
	
	// WAIT FOR ACK_TO
	// check channel and busy: go into backoff
	[] s1=11 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=11 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	[time] s1=11 &amp; x1&gt;0 &amp; x1&lt;ACK_TO -&gt; (x1'=min(x1+1,TIME_MAX));
	// no acknowledgement (go to backoff waiting DIFS first)
	[] s1=11 &amp; x1=ACK_TO -&gt; (s1'=3) &amp; (x1'=0);
		
	// DONE
	[time] s1=12 -&gt; (s1'=12);
endmodule	

// ---------------------------------------------------------------------------- //
// STATION 2 (rename STATION 1)
module 
station2=station1[x1=x2, 
                  s1=s2,
				  s2=s1,
				  c1=c2,
				  c2=c1, 
				  slot1=slot2, 
				  backoff1=backoff2, 
				  bc1=bc2, 
				  send1=send2, 
				  finish1=finish2] 
endmodule
// ---------------------------------------------------------------------------- //

// reward structures

// number of collisions
rewards "collisions"
	[send1] c1=0 &amp; c2&gt;0 : 1; // station one starts transmitting and station two is already transmitting
	[send2] c2=0 &amp; c1&gt;0 : 1; // station two starts transmitting and station one is already transmitting
endrewards

// reward structure for expected time
// recall one time unit equals ASLOT(=50{\mu}s)
rewards "time"
	[time] true : 50;
endrewards

// reward strcuture for expected cost
// cost (per time unit) is set to:
// 1 in locations where the channel is free,
// 10 in locations where the channel is in use and a message is being sent correctly
// 1000 in locations where a station is sending a garbled message
// 2000 in locations where both stations are sending garbled messages
rewards	"cost"
	[time] c1=0 &amp; c2=0 : 50;
	[time] c1+c2=1 : 50*10;
	[time] c1=1 &amp; c2=1 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=0 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=0 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*2000;
endrewards</content>
    </model>
    <model name="wlan_3" type="rml">
      <content>// WLAN PROTOCOL (two stations)
// discrete time model
// gxn/jzs 20/02/02

mdp

// COLLISIONS
const int COL=2; // maximum number of collisions

// TIMING CONSTRAINTS
// we have used the FHSS parameters
// then scaled by the value of ASLOTTIME
const ASLOTTIME = 1;
const DIFS = 3; // due to scaling can be either 2 or 3 which is modelled by a non-deterministic choice
const VULN = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
const TRANS_TIME_MAX = 10; // scaling up
const TRANS_TIME_MIN = 4; // scaling down
const ACK_TO = 6; 
const ACK = 4; // due to scaling can be either 3 or 4 which is modelled by a non-deterministic choice
const SIFS = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
// maximum constant used in timing constraints + 1
const TIME_MAX = max(ACK_TO,TRANS_TIME_MAX)+1;

// CONTENTION WINDOW
// CWMIN =15 &amp; CWMAX =127
// this means that MAX_BACKOFF IS 3
const MAX_BACKOFF = 3;

//-----------------------------------------------------------------//
// THE MEDIUM/CHANNEL

// FORMULAE FOR THE CHANNEL
// channel is busy
formula busy = c1&gt;0 | c2&gt;0;
// channel is free
formula free = c1=0 &amp; c2=0;

module medium
	
	// number of collisions
	col : [0..COL+1];
	
	// medium status 
	c1 : [0..2];
	c2 : [0..2];
	// ci corresponds to messages associated with station i
	// 0 nothing being sent
	// 1 being sent correctly
	// 2 being sent garbled	  
	
	// begin sending message and nothing else currently being sent
	[send1] c1=0 &amp; c2=0 -&gt; (c1'=1);
	[send2] c2=0 &amp; c1=0 -&gt; (c2'=1);
	
	// begin sending message and  something is already being sent
	// in this case both messages become garbled
	[send1] c1=0 &amp; c2&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	[send2] c2=0 &amp; c1&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	
	// finish sending message
	[finish1] c1&gt;0 -&gt; (c1'=0);
	[finish2] c2&gt;0 -&gt; (c2'=0);

endmodule

//-----------------------------------------------------------------//
// STATION 1
module station1
	// clock for station 1
	x1 : [0..TIME_MAX];
	
	// local state
	s1 : [1..12];
	// 1 sense
	// 2 wait until free before setting backoff
	// 3 wait for DIFS then set slot
	// 4 set backoff 
	// 5 backoff
	// 6 wait until free in backoff
	// 7 wait for DIFS then resume backoff
	// 8 vulnerable 
	// 9 transmit
	// 11 wait for SIFS and then ACK
	// 10 wait for ACT_TO 
	// 12 done
	// BACKOFF
	// separate into slots
	slot1 : [0..7]; 
	backoff1 : [0..15];
	
	// BACKOFF COUNTER
	bc1 : [0..MAX_BACKOFF];
	// SENSE
	// let time pass
	[time] s1=1 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// ready to transmit
	[] s1=1 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy so wait until free
	[] s1=1 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// WAIT UNTIL FREE BEFORE SETTING BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=2 &amp; busy -&gt; (s1'=2);
	// find that channel is free so check its free for DIFS before setting backoff
	[] s1=2 &amp; free -&gt; (s1'=3);
	// WAIT FOR DIFS THEN SET BACKOFF
	// let time pass
	[time] s1=3 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// found channel busy so wait until free
	[] s1=3 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// start backoff  first uniformly choose slot
	// backoff counter 0
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=0 -&gt; (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 1
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=1 -&gt; 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 2
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=2 -&gt; 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 3
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=3 -&gt; 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// SET BACKOFF (no time can pass)
	// chosen slot now set backoff
	[] s1=4 -&gt; 1/16 : (s1'=5) &amp; (backoff1'=0 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=1 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=2 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=3 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=4 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=5 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=6 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=7 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=8 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=9 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=10)
	         + 1/16 : (s1'=5) &amp; (backoff1'=11)
	         + 1/16 : (s1'=5) &amp; (backoff1'=12)
	         + 1/16 : (s1'=5) &amp; (backoff1'=13)
	         + 1/16 : (s1'=5) &amp; (backoff1'=14)
	         + 1/16 : (s1'=5) &amp; (backoff1'=15);
	// BACKOFF
	// let time pass
	[time] s1=5 &amp; x1&lt;ASLOTTIME &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// decrement backoff
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=backoff1-1);	
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=15) &amp; (slot1'=slot1-1);	
	// finish backoff 
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1=0 -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy
	[] s1=5 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	// WAIT UNTIL FREE IN BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=6 &amp; busy -&gt; (s1'=6);
	// find that channel is free
	[] s1=6 &amp; free -&gt; (s1'=7);
	
	// WAIT FOR DIFS THEN RESUME BACKOFF
	// let time pass
	[time] s1=7 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// resume backoff (start again from previous backoff)
	[] s1=7 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=5) &amp; (x1'=0);
	// found channel busy
	[] s1=7 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	
	// VULNERABLE
	// let time pass
	[time] s1=8 &amp; x1&lt;VULN -&gt; (x1'=min(x1+1,TIME_MAX));
	// move to transmit
	[send1] s1=8 &amp; (x1=VULN | x1=VULN-1) -&gt; (s1'=9) &amp; (x1'=0);
	// TRANSMIT
	// let time pass
	[time] s1=9 &amp; x1&lt;TRANS_TIME_MAX -&gt; (x1'=min(x1+1,TIME_MAX));
	// finish transmission successful	
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=1 -&gt; (s1'=10) &amp; (x1'=0);
	// finish transmission garbled
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=2 -&gt; (s1'=11) &amp; (x1'=0);
	// WAIT FOR SIFS THEN WAIT FOR ACK
	
	// WAIT FOR SIFS i.e. c1=0
	// check channel and busy: go into backoff
	[] s1=10 &amp; c1=0 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=10 &amp; c1=0 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	// following guard is always false as SIFS=1
	// [time] s1=10 &amp; c1=0 &amp; x1&gt;0 &amp; x1&lt;SIFS -&gt; (x1'=min(x1+1,TIME_MAX));
	// ack is sent after SIFS (since SIFS-1=0 add condition that channel is free)
	[send1] s1=10 &amp; c1=0 &amp; (x1=SIFS | (x1=SIFS-1 &amp; free)) -&gt; (s1'=10) &amp; (x1'=0);
	
	// WAIT FOR ACK i.e. c1=1
	// let time pass
	[time] s1=10 &amp; c1=1 &amp; x1&lt;ACK -&gt; (x1'=min(x1+1,TIME_MAX));
	// get acknowledgement so packet sent correctly and move to done
	[finish1] s1=10 &amp; c1=1 &amp; (x1=ACK | x1=ACK-1) -&gt; (s1'=12) &amp; (x1'=0) &amp; (bc1'=0);
	
	// WAIT FOR ACK_TO
	// check channel and busy: go into backoff
	[] s1=11 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=11 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	[time] s1=11 &amp; x1&gt;0 &amp; x1&lt;ACK_TO -&gt; (x1'=min(x1+1,TIME_MAX));
	// no acknowledgement (go to backoff waiting DIFS first)
	[] s1=11 &amp; x1=ACK_TO -&gt; (s1'=3) &amp; (x1'=0);
		
	// DONE
	[time] s1=12 -&gt; (s1'=12);
endmodule	

// ---------------------------------------------------------------------------- //
// STATION 2 (rename STATION 1)
module 
station2=station1[x1=x2, 
                  s1=s2,
				  s2=s1,
				  c1=c2,
				  c2=c1, 
				  slot1=slot2, 
				  backoff1=backoff2, 
				  bc1=bc2, 
				  send1=send2, 
				  finish1=finish2] 
endmodule
// ---------------------------------------------------------------------------- //

// reward structures

// number of collisions
rewards "collisions"
	[send1] c1=0 &amp; c2&gt;0 : 1; // station one starts transmitting and station two is already transmitting
	[send2] c2=0 &amp; c1&gt;0 : 1; // station two starts transmitting and station one is already transmitting
endrewards

// reward structure for expected time
// recall one time unit equals ASLOT(=50{\mu}s)
rewards "time"
	[time] true : 50;
endrewards

// reward strcuture for expected cost
// cost (per time unit) is set to:
// 1 in locations where the channel is free,
// 10 in locations where the channel is in use and a message is being sent correctly
// 1000 in locations where a station is sending a garbled message
// 2000 in locations where both stations are sending garbled messages
rewards	"cost"
	[time] c1=0 &amp; c2=0 : 50;
	[time] c1+c2=1 : 50*10;
	[time] c1=1 &amp; c2=1 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=0 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=0 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*2000;
endrewards</content>
    </model>
    <model name="wlan_5" type="rml">
      <content>// WLAN PROTOCOL (two stations)
// discrete time model
// gxn/jzs 20/02/02

mdp

// COLLISIONS
const int COL = 2; // maximum number of collisions

// TIMING CONSTRAINTS
// we have used the FHSS parameters
// then scaled by the value of ASLOTTIME
const ASLOTTIME = 1;
const DIFS = 3; // due to scaling can be either 2 or 3 which is modelled by a non-deterministic choice
const VULN = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
const TRANS_TIME_MAX = 10; // scaling up
const TRANS_TIME_MIN = 4; // scaling down
const ACK_TO = 6; 
const ACK = 4; // due to scaling can be either 3 or 4 which is modelled by a non-deterministic choice
const SIFS = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
// maximum constant used in timing constraints + 1
const TIME_MAX = max(ACK_TO,TRANS_TIME_MAX)+1;

// CONTENTION WINDOW
// CWMIN =15 &amp; CWMAX =511
// this means that MAX_BACKOFF IS 5
const MAX_BACKOFF = 5;

//-----------------------------------------------------------------//
// THE MEDIUM/CHANNEL

// FORMULAE FOR THE CHANNEL
// channel is busy
formula busy = c1&gt;0 | c2&gt;0;
// channel is free
formula free = c1=0 &amp; c2=0;

module medium
	
	// number of collisions
	col : [0..COL+1];
	
	// medium status 
	c1 : [0..2];
	c2 : [0..2];
	// ci corresponds to messages associated with station i
	// 0 nothing being sent
	// 1 being sent correctly
	// 2 being sent garbled	  
	
	// begin sending message and nothing else currently being sent
	[send1] c1=0 &amp; c2=0 -&gt; (c1'=1);
	[send2] c2=0 &amp; c1=0 -&gt; (c2'=1);
	
	// begin sending message and  something is already being sent
	// in this case both messages become garbled
	[send1] c1=0 &amp; c2&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	[send2] c2=0 &amp; c1&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	
	// finish sending message
	[finish1] c1&gt;0 -&gt; (c1'=0);
	[finish2] c2&gt;0 -&gt; (c2'=0);

endmodule

//-----------------------------------------------------------------//
// STATION 1
module station1
	// clock for station 1
	x1 : [0..TIME_MAX];
	
	// local state
	s1 : [1..12];
	// 1 sense
	// 2 wait until free before setting backoff
	// 3 wait for DIFS then set slot
	// 4 set backoff 
	// 5 backoff
	// 6 wait until free in backoff
	// 7 wait for DIFS then resume backoff
	// 8 vulnerable 
	// 9 transmit
	// 11 wait for SIFS and then ACK
	// 10 wait for ACT_TO 
	// 12 done
	// BACKOFF
	// separate into slots
	slot1 : [0..31]; 
	backoff1 : [0..15];
	
	// BACKOFF COUNTER
	bc1 : [0..MAX_BACKOFF];
	// SENSE
	// let time pass
	[time] s1=1 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// ready to transmit
	[] s1=1 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy so wait until free
	[] s1=1 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// WAIT UNTIL FREE BEFORE SETTING BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=2 &amp; busy -&gt; (s1'=2);
	// find that channel is free so check its free for DIFS before setting backoff
	[] s1=2 &amp; free -&gt; (s1'=3);
	// WAIT FOR DIFS THEN SET BACKOFF
	// let time pass
	[time] s1=3 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// found channel busy so wait until free
	[] s1=3 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// start backoff  first uniformly choose slot
	// backoff counter 0
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=0 -&gt; (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 1
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=1 -&gt; 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 2
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=2 -&gt; 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 3
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=3 -&gt; 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 4
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=4 -&gt; 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=8 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=9 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=10) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=11) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=12) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=13) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=14) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=15) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 5
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=5 -&gt; 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=8 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=9 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=10) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=11) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=12) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=13) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=14) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=15) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=16) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=17) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=18) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=19) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=20) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=21) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=22) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=23) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=24) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=25) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=26) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=27) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=28) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=29) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=30) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=31) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
																					 
	// SET BACKOFF (no time can pass)
	// chosen slot now set backoff
	[] s1=4 -&gt; 1/16 : (s1'=5) &amp; (backoff1'=0 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=1 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=2 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=3 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=4 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=5 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=6 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=7 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=8 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=9 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=10)
	         + 1/16 : (s1'=5) &amp; (backoff1'=11)
	         + 1/16 : (s1'=5) &amp; (backoff1'=12)
	         + 1/16 : (s1'=5) &amp; (backoff1'=13)
	         + 1/16 : (s1'=5) &amp; (backoff1'=14)
	         + 1/16 : (s1'=5) &amp; (backoff1'=15);
	// BACKOFF
	// let time pass
	[time] s1=5 &amp; x1&lt;ASLOTTIME &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// decrement backoff
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=backoff1-1);	
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=15) &amp; (slot1'=slot1-1);	
	// finish backoff 
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1=0 -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy
	[] s1=5 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	// WAIT UNTIL FREE IN BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=6 &amp; busy -&gt; (s1'=6);
	// find that channel is free
	[] s1=6 &amp; free -&gt; (s1'=7);
	
	// WAIT FOR DIFS THEN RESUME BACKOFF
	// let time pass
	[time] s1=7 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// resume backoff (start again from previous backoff)
	[] s1=7 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=5) &amp; (x1'=0);
	// found channel busy
	[] s1=7 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	
	// VULNERABLE
	// let time pass
	[time] s1=8 &amp; x1&lt;VULN -&gt; (x1'=min(x1+1,TIME_MAX));
	// move to transmit
	[send1] s1=8 &amp; (x1=VULN | x1=VULN-1) -&gt; (s1'=9) &amp; (x1'=0);
	// TRANSMIT
	// let time pass
	[time] s1=9 &amp; x1&lt;TRANS_TIME_MAX -&gt; (x1'=min(x1+1,TIME_MAX));
	// finish transmission successful	
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=1 -&gt; (s1'=10) &amp; (x1'=0);
	// finish transmission garbled
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=2 -&gt; (s1'=11) &amp; (x1'=0);
	// WAIT FOR SIFS THEN WAIT FOR ACK
	
	// WAIT FOR SIFS i.e. c1=0
	// check channel and busy: go into backoff
	[] s1=10 &amp; c1=0 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=10 &amp; c1=0 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	// following guard is always false as SIFS=1
	// [time] s1=10 &amp; c1=0 &amp; x1&gt;0 &amp; x1&lt;SIFS -&gt; (x1'=min(x1+1,TIME_MAX));
	// ack is sent after SIFS (since SIFS-1=0 add condition that channel is free)
	[send1] s1=10 &amp; c1=0 &amp; (x1=SIFS | (x1=SIFS-1 &amp; free)) -&gt; (s1'=10) &amp; (x1'=0);
	
	// WAIT FOR ACK i.e. c1=1
	// let time pass
	[time] s1=10 &amp; c1=1 &amp; x1&lt;ACK -&gt; (x1'=min(x1+1,TIME_MAX));
	// get acknowledgement so packet sent correctly and move to done
	[finish1] s1=10 &amp; c1=1 &amp; (x1=ACK | x1=ACK-1) -&gt; (s1'=12) &amp; (x1'=0) &amp; (bc1'=0);
	
	// WAIT FOR ACK_TO
	// check channel and busy: go into backoff
	[] s1=11 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=11 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	[time] s1=11 &amp; x1&gt;0 &amp; x1&lt;ACK_TO -&gt; (x1'=min(x1+1,TIME_MAX));
	// no acknowledgement (go to backoff waiting DIFS first)
	[] s1=11 &amp; x1=ACK_TO -&gt; (s1'=3) &amp; (x1'=0);
		
	// DONE
	[time] s1=12 -&gt; (s1'=12);
endmodule	

// ---------------------------------------------------------------------------- //
// STATION 2 (rename STATION 1)
module 
station2=station1[x1=x2, 
                  s1=s2,
				  s2=s1,
				  c1=c2,
				  c2=c1, 
				  slot1=slot2, 
				  backoff1=backoff2, 
				  bc1=bc2, 
				  send1=send2, 
				  finish1=finish2] 
endmodule
// ---------------------------------------------------------------------------- //

// reward structures

// number of collisions
rewards "collisions"
	[send1] c1=0 &amp; c2&gt;0 : 1; // station one starts transmitting and station two is already transmitting
	[send2] c2=0 &amp; c1&gt;0 : 1; // station two starts transmitting and station one is already transmitting
endrewards

// reward structure for expected time
// recall one time unit equals ASLOT(=50{\mu}s)
rewards "time"
	[time] true : 50;
endrewards

// reward strcuture for expected cost
// cost (per time unit) is set to:
// 1 in locations where the channel is free,
// 10 in locations where the channel is in use and a message is being sent correctly
// 1000 in locations where a station is sending a garbled message
// 2000 in locations where both stations are sending garbled messages
rewards	"cost"
	[time] c1=0 &amp; c2=0 : 50;
	[time] c1+c2=1 : 50*10;
	[time] c1=1 &amp; c2=1 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=0 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=0 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*2000;
endrewards</content>
    </model>
    <model name="wlan_6" type="rml">
      <content>// WLAN PROTOCOL (two stations)
// discrete time model
// gxn/jzs 20/02/02

mdp

// COLLISIONS
const int COL=2; // maximum number of collisions

// TIMING CONSTRAINTS
// we have used the FHSS parameters
// then scaled by the value of ASLOTTIME
const ASLOTTIME = 1;
const DIFS = 3; // due to scaling can be either 2 or 3 which is modelled by a non-deterministic choice
const VULN = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
const TRANS_TIME_MAX = 10; // scaling up
const TRANS_TIME_MIN = 4; // scaling down
const ACK_TO = 6; 
const ACK = 4; // due to scaling can be either 3 or 4 which is modelled by a non-deterministic choice
const SIFS = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
// maximum constant used in timing constraints + 1
const TIME_MAX = max(ACK_TO,TRANS_TIME_MAX)+1;

// CONTENTION WINDOW
// CWMIN =15 &amp; CWMAX =1023
// this means that MAX_BACKOFF IS 6
const MAX_BACKOFF = 6;

//-----------------------------------------------------------------//
// THE MEDIUM/CHANNEL

// FORMULAE FOR THE CHANNEL
// channel is busy
formula busy = c1&gt;0 | c2&gt;0;
// channel is free
formula free = c1=0 &amp; c2=0;

module medium
	
	// number of collisions
	col : [0..COL+1];
	
	// medium status 
	c1 : [0..2];
	c2 : [0..2];
	// ci corresponds to messages associated with station i
	// 0 nothing being sent
	// 1 being sent correctly
	// 2 being sent garbled	  
	
	// begin sending message and nothing else currently being sent
	[send1] c1=0 &amp; c2=0 -&gt; (c1'=1);
	[send2] c2=0 &amp; c1=0 -&gt; (c2'=1);
	
	// begin sending message and  something is already being sent
	// in this case both messages become garbled
	[send1] c1=0 &amp; c2&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	[send2] c2=0 &amp; c1&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	
	// finish sending message
	[finish1] c1&gt;0 -&gt; (c1'=0);
	[finish2] c2&gt;0 -&gt; (c2'=0);

endmodule

//-----------------------------------------------------------------//
// STATION 1
module station1
	// clock for station 1
	x1 : [0..TIME_MAX];
	
	// local state
	s1 : [1..12];
	// 1 sense
	// 2 wait until free before setting backoff
	// 3 wait for DIFS then set slot
	// 4 set backoff 
	// 5 backoff
	// 6 wait until free in backoff
	// 7 wait for DIFS then resume backoff
	// 8 vulnerable 
	// 9 transmit
	// 11 wait for SIFS and then ACK
	// 10 wait for ACT_TO 
	// 12 done
	// BACKOFF
	// separate into slots
	slot1 : [0..63]; 
	backoff1 : [0..15];
	
	// BACKOFF COUNTER
	bc1 : [0..MAX_BACKOFF];
	// SENSE
	// let time pass
	[time] s1=1 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// ready to transmit
	[] s1=1 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy so wait until free
	[] s1=1 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// WAIT UNTIL FREE BEFORE SETTING BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=2 &amp; busy -&gt; (s1'=2);
	// find that channel is free so check its free for DIFS before setting backoff
	[] s1=2 &amp; free -&gt; (s1'=3);
	// WAIT FOR DIFS THEN SET BACKOFF
	// let time pass
	[time] s1=3 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// found channel busy so wait until free
	[] s1=3 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// start backoff  first uniformly choose slot
	// backoff counter 0
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=0 -&gt; (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 1
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=1 -&gt; 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 2
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=2 -&gt; 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 3
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=3 -&gt; 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 4
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=4 -&gt; 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=8 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=9 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=10) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=11) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=12) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=13) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=14) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=15) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 5
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=5 -&gt; 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=8 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=9 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=10) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=11) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=12) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=13) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=14) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=15) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=16) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=17) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=18) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=19) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=20) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=21) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=22) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=23) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=24) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=25) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=26) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=27) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=28) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=29) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=30) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/32 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=31) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
																					 
	// backoff counter 6
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=6 -&gt; 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=8 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=9 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=10) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=11) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=12) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=13) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=14) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=15) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=16) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=17) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=18) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=19) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=20) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=21) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=22) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=23) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=24) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=25) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=26) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=27) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=28) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=29) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=30) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=31) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=32) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=33) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=34) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=35) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=36) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=37) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=38) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=39) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=40) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=41) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=42) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=43) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=44) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=45) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=46) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=47) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=48) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=49) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=50) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=51) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=52) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=53) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=54) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=55) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=56) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=57) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=58) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=59) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=60) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=61) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=62) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/64 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=63) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// SET BACKOFF (no time can pass)
	// chosen slot now set backoff
	[] s1=4 -&gt; 1/16 : (s1'=5) &amp; (backoff1'=0 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=1 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=2 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=3 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=4 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=5 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=6 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=7 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=8 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=9 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=10)
	         + 1/16 : (s1'=5) &amp; (backoff1'=11)
	         + 1/16 : (s1'=5) &amp; (backoff1'=12)
	         + 1/16 : (s1'=5) &amp; (backoff1'=13)
	         + 1/16 : (s1'=5) &amp; (backoff1'=14)
	         + 1/16 : (s1'=5) &amp; (backoff1'=15);
	// BACKOFF
	// let time pass
	[time] s1=5 &amp; x1&lt;ASLOTTIME &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// decrement backoff
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=backoff1-1);	
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=15) &amp; (slot1'=slot1-1);	
	// finish backoff 
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1=0 -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy
	[] s1=5 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	// WAIT UNTIL FREE IN BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=6 &amp; busy -&gt; (s1'=6);
	// find that channel is free
	[] s1=6 &amp; free -&gt; (s1'=7);
	
	// WAIT FOR DIFS THEN RESUME BACKOFF
	// let time pass
	[time] s1=7 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// resume backoff (start again from previous backoff)
	[] s1=7 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=5) &amp; (x1'=0);
	// found channel busy
	[] s1=7 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	
	// VULNERABLE
	// let time pass
	[time] s1=8 &amp; x1&lt;VULN -&gt; (x1'=min(x1+1,TIME_MAX));
	// move to transmit
	[send1] s1=8 &amp; (x1=VULN | x1=VULN-1) -&gt; (s1'=9) &amp; (x1'=0);
	// TRANSMIT
	// let time pass
	[time] s1=9 &amp; x1&lt;TRANS_TIME_MAX -&gt; (x1'=min(x1+1,TIME_MAX));
	// finish transmission successful	
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=1 -&gt; (s1'=10) &amp; (x1'=0);
	// finish transmission garbled
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=2 -&gt; (s1'=11) &amp; (x1'=0);
	// WAIT FOR SIFS THEN WAIT FOR ACK
	
	// WAIT FOR SIFS i.e. c1=0
	// check channel and busy: go into backoff
	[] s1=10 &amp; c1=0 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=10 &amp; c1=0 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	// following guard is always false as SIFS=1
	// [time] s1=10 &amp; c1=0 &amp; x1&gt;0 &amp; x1&lt;SIFS -&gt; (x1'=min(x1+1,TIME_MAX));
	// ack is sent after SIFS (since SIFS-1=0 add condition that channel is free)
	[send1] s1=10 &amp; c1=0 &amp; (x1=SIFS | (x1=SIFS-1 &amp; free)) -&gt; (s1'=10) &amp; (x1'=0);
	
	// WAIT FOR ACK i.e. c1=1
	// let time pass
	[time] s1=10 &amp; c1=1 &amp; x1&lt;ACK -&gt; (x1'=min(x1+1,TIME_MAX));
	// get acknowledgement so packet sent correctly and move to done
	[finish1] s1=10 &amp; c1=1 &amp; (x1=ACK | x1=ACK-1) -&gt; (s1'=12) &amp; (x1'=0) &amp; (bc1'=0);
	
	// WAIT FOR ACK_TO
	// check channel and busy: go into backoff
	[] s1=11 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=11 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	[time] s1=11 &amp; x1&gt;0 &amp; x1&lt;ACK_TO -&gt; (x1'=min(x1+1,TIME_MAX));
	// no acknowledgement (go to backoff waiting DIFS first)
	[] s1=11 &amp; x1=ACK_TO -&gt; (s1'=3) &amp; (x1'=0);
		
	// DONE
	[time] s1=12 -&gt; (s1'=12);
endmodule	

// ---------------------------------------------------------------------------- //
// STATION 2 (rename STATION 1)
module 
station2=station1[x1=x2, 
                  s1=s2,
				  s2=s1,
				  c1=c2,
				  c2=c1, 
				  slot1=slot2, 
				  backoff1=backoff2, 
				  bc1=bc2, 
				  send1=send2, 
				  finish1=finish2] 
endmodule
// ---------------------------------------------------------------------------- //

// reward structures

// number of collisions
rewards "collisions"
	[send1] c1=0 &amp; c2&gt;0 : 1; // station one starts transmitting and station two is already transmitting
	[send2] c2=0 &amp; c1&gt;0 : 1; // station two starts transmitting and station one is already transmitting
endrewards

// reward structure for expected time
// recall one time unit equals ASLOT(=50{\mu}s)
rewards "time"
	[time] true : 50;
endrewards

// reward strcuture for expected cost
// cost (per time unit) is set to:
// 1 in locations where the channel is free,
// 10 in locations where the channel is in use and a message is being sent correctly
// 1000 in locations where a station is sending a garbled message
// 2000 in locations where both stations are sending garbled messages
rewards	"cost"
	[time] c1=0 &amp; c2=0 : 50;
	[time] c1+c2=1 : 50*10;
	[time] c1=1 &amp; c2=1 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=0 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=0 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*2000;
endrewards</content>
    </model>
    <model name="wlan_4" type="rml">
      <content>// WLAN PROTOCOL (two stations)
// discrete time model
// gxn/jzs 20/02/02

mdp

// COLLISIONS
const int COL=2; // maximum number of collisions

// TIMING CONSTRAINTS
// we have used the FHSS parameters
// then scaled by the value of ASLOTTIME
const ASLOTTIME = 1;
const DIFS = 3; // due to scaling can be either 2 or 3 which is modelled by a non-deterministic choice
const VULN = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
const TRANS_TIME_MAX = 10; // scaling up
const TRANS_TIME_MIN = 4; // scaling down
const ACK_TO = 6; 
const ACK = 4; // due to scaling can be either 3 or 4 which is modelled by a non-deterministic choice
const SIFS = 1; // due to scaling can be either 0 or 1 which is modelled by a non-deterministic choice
// maximum constant used in timing constraints + 1
const TIME_MAX = max(ACK_TO,TRANS_TIME_MAX)+1;

// CONTENTION WINDOW
// CWMIN =15 &amp; CWMAX =255
// this means that MAX_BACKOFF IS 4
const MAX_BACKOFF = 4;

//-----------------------------------------------------------------//
// THE MEDIUM/CHANNEL

// FORMULAE FOR THE CHANNEL
// channel is busy
formula busy = c1&gt;0 | c2&gt;0;
// channel is free
formula free = c1=0 &amp; c2=0;

module medium
	
	// number of collisions
	col : [0..COL+1];
	
	// medium status 
	c1 : [0..2];
	c2 : [0..2];
	// ci corresponds to messages associated with station i
	// 0 nothing being sent
	// 1 being sent correctly
	// 2 being sent garbled	  
	
	// begin sending message and nothing else currently being sent
	[send1] c1=0 &amp; c2=0 -&gt; (c1'=1);
	[send2] c2=0 &amp; c1=0 -&gt; (c2'=1);
	
	// begin sending message and  something is already being sent
	// in this case both messages become garbled
	[send1] c1=0 &amp; c2&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	[send2] c2=0 &amp; c1&gt;0 -&gt; (c1'=2) &amp; (c2'=2) &amp; (col'=min(col+1,COL));
	
	// finish sending message
	[finish1] c1&gt;0 -&gt; (c1'=0);
	[finish2] c2&gt;0 -&gt; (c2'=0);

endmodule

//-----------------------------------------------------------------//
// STATION 1
module station1
	// clock for station 1
	x1 : [0..TIME_MAX];
	
	// local state
	s1 : [1..12];
	// 1 sense
	// 2 wait until free before setting backoff
	// 3 wait for DIFS then set slot
	// 4 set backoff 
	// 5 backoff
	// 6 wait until free in backoff
	// 7 wait for DIFS then resume backoff
	// 8 vulnerable 
	// 9 transmit
	// 11 wait for SIFS and then ACK
	// 10 wait for ACT_TO 
	// 12 done
	// BACKOFF
	// separate into slots
	slot1 : [0..15]; 
	backoff1 : [0..15];
	
	// BACKOFF COUNTER
	bc1 : [0..MAX_BACKOFF];
	// SENSE
	// let time pass
	[time] s1=1 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// ready to transmit
	[] s1=1 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy so wait until free
	[] s1=1 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// WAIT UNTIL FREE BEFORE SETTING BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=2 &amp; busy -&gt; (s1'=2);
	// find that channel is free so check its free for DIFS before setting backoff
	[] s1=2 &amp; free -&gt; (s1'=3);
	// WAIT FOR DIFS THEN SET BACKOFF
	// let time pass
	[time] s1=3 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// found channel busy so wait until free
	[] s1=3 &amp; busy -&gt; (s1'=2) &amp; (x1'=0);
	// start backoff  first uniformly choose slot
	// backoff counter 0
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=0 -&gt; (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 1
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=1 -&gt; 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/2 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 2
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=2 -&gt; 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/4 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 3
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=3 -&gt; 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/8 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// backoff counter 4
	[] s1=3 &amp; (x1=DIFS | x1=DIFS-1) &amp; bc1=4 -&gt; 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=0 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=1 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=2 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=3 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=4 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=5 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=6 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=7 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=8 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=9 ) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=10) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=11) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=12) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=13) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=14) &amp; (bc1'=min(bc1+1,MAX_BACKOFF))
	                                         + 1/16 : (s1'=4) &amp; (x1'=0) &amp; (slot1'=15) &amp; (bc1'=min(bc1+1,MAX_BACKOFF));
	// SET BACKOFF (no time can pass)
	// chosen slot now set backoff
	[] s1=4 -&gt; 1/16 : (s1'=5) &amp; (backoff1'=0 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=1 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=2 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=3 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=4 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=5 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=6 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=7 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=8 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=9 )
	         + 1/16 : (s1'=5) &amp; (backoff1'=10)
	         + 1/16 : (s1'=5) &amp; (backoff1'=11)
	         + 1/16 : (s1'=5) &amp; (backoff1'=12)
	         + 1/16 : (s1'=5) &amp; (backoff1'=13)
	         + 1/16 : (s1'=5) &amp; (backoff1'=14)
	         + 1/16 : (s1'=5) &amp; (backoff1'=15);
	// BACKOFF
	// let time pass
	[time] s1=5 &amp; x1&lt;ASLOTTIME &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// decrement backoff
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=backoff1-1);	
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1&gt;0 -&gt; (s1'=5) &amp; (x1'=0) &amp; (backoff1'=15) &amp; (slot1'=slot1-1);	
	// finish backoff 
	[] s1=5 &amp; x1=ASLOTTIME &amp; backoff1=0 &amp; slot1=0 -&gt; (s1'=8) &amp; (x1'=0);
	// found channel busy
	[] s1=5 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	// WAIT UNTIL FREE IN BACKOFF
	// let time pass (no need for the clock x1 to change)
	[time] s1=6 &amp; busy -&gt; (s1'=6);
	// find that channel is free
	[] s1=6 &amp; free -&gt; (s1'=7);
	
	// WAIT FOR DIFS THEN RESUME BACKOFF
	// let time pass
	[time] s1=7 &amp; x1&lt;DIFS &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// resume backoff (start again from previous backoff)
	[] s1=7 &amp; (x1=DIFS | x1=DIFS-1) -&gt; (s1'=5) &amp; (x1'=0);
	// found channel busy
	[] s1=7 &amp; busy -&gt; (s1'=6) &amp; (x1'=0);
	
	// VULNERABLE
	// let time pass
	[time] s1=8 &amp; x1&lt;VULN -&gt; (x1'=min(x1+1,TIME_MAX));
	// move to transmit
	[send1] s1=8 &amp; (x1=VULN | x1=VULN-1) -&gt; (s1'=9) &amp; (x1'=0);
	// TRANSMIT
	// let time pass
	[time] s1=9 &amp; x1&lt;TRANS_TIME_MAX -&gt; (x1'=min(x1+1,TIME_MAX));
	// finish transmission successful	
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=1 -&gt; (s1'=10) &amp; (x1'=0);
	// finish transmission garbled
	[finish1] s1=9 &amp; x1&gt;=TRANS_TIME_MIN &amp; c1=2 -&gt; (s1'=11) &amp; (x1'=0);
	// WAIT FOR SIFS THEN WAIT FOR ACK
	
	// WAIT FOR SIFS i.e. c1=0
	// check channel and busy: go into backoff
	[] s1=10 &amp; c1=0 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=10 &amp; c1=0 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	// following guard is always false as SIFS=1
	// [time] s1=10 &amp; c1=0 &amp; x1&gt;0 &amp; x1&lt;SIFS -&gt; (x1'=min(x1+1,TIME_MAX));
	// ack is sent after SIFS (since SIFS-1=0 add condition that channel is free)
	[send1] s1=10 &amp; c1=0 &amp; (x1=SIFS | (x1=SIFS-1 &amp; free)) -&gt; (s1'=10) &amp; (x1'=0);
	
	// WAIT FOR ACK i.e. c1=1
	// let time pass
	[time] s1=10 &amp; c1=1 &amp; x1&lt;ACK -&gt; (x1'=min(x1+1,TIME_MAX));
	// get acknowledgement so packet sent correctly and move to done
	[finish1] s1=10 &amp; c1=1 &amp; (x1=ACK | x1=ACK-1) -&gt; (s1'=12) &amp; (x1'=0) &amp; (bc1'=0);
	
	// WAIT FOR ACK_TO
	// check channel and busy: go into backoff
	[] s1=11 &amp; x1=0 &amp; busy -&gt; (s1'=2);
	// check channel and free: let time pass
	[time] s1=11 &amp; x1=0 &amp; free -&gt; (x1'=min(x1+1,TIME_MAX));
	// let time pass
	[time] s1=11 &amp; x1&gt;0 &amp; x1&lt;ACK_TO -&gt; (x1'=min(x1+1,TIME_MAX));
	// no acknowledgement (go to backoff waiting DIFS first)
	[] s1=11 &amp; x1=ACK_TO -&gt; (s1'=3) &amp; (x1'=0);
		
	// DONE
	[time] s1=12 -&gt; (s1'=12);
endmodule	

// ---------------------------------------------------------------------------- //
// STATION 2 (rename STATION 1)
module 
station2=station1[x1=x2, 
                  s1=s2,
				  s2=s1,
				  c1=c2,
				  c2=c1, 
				  slot1=slot2, 
				  backoff1=backoff2, 
				  bc1=bc2, 
				  send1=send2, 
				  finish1=finish2] 
endmodule
// ---------------------------------------------------------------------------- //

// reward structures

// number of collisions
rewards "collisions"
	[send1] c1=0 &amp; c2&gt;0 : 1; // station one starts transmitting and station two is already transmitting
	[send2] c2=0 &amp; c1&gt;0 : 1; // station two starts transmitting and station one is already transmitting
endrewards

// reward structure for expected time
// recall one time unit equals ASLOT(=50{\mu}s)
rewards "time"
	[time] true : 50;
endrewards

// reward strcuture for expected cost
// cost (per time unit) is set to:
// 1 in locations where the channel is free,
// 10 in locations where the channel is in use and a message is being sent correctly
// 1000 in locations where a station is sending a garbled message
// 2000 in locations where both stations are sending garbled messages
rewards	"cost"
	[time] c1=0 &amp; c2=0 : 50;
	[time] c1+c2=1 : 50*10;
	[time] c1=1 &amp; c2=1 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=0 &amp; bc1=0 &amp; bc2=0 : 50*10;
	[time] c1=2 &amp; c2=2 &amp; bc1=0 &amp; bc2=0 : 50*20;
	[time] c1=0 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=0 &amp; (bc1&gt;0 | bc2&gt;0) : 50*1000;
	[time] c1=2 &amp; c2=2 &amp; (bc1&gt;0 | bc2&gt;0) : 50*2000;
endrewards</content>
    </model>
  </models>
  <requirements>
    <requirement name="collisions" type="bltl">
      <content>F&lt;=#100 col=COL</content>
    </requirement>
    <requirement name="mean" type="bltl">
      <content>X &lt;=# 1000 s1</content>
    </requirement>
  </requirements>
  <resources />
</PlasmaProject>
